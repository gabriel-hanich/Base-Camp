{"ast":null,"code":"import { iif, fromEvent, merge, Observable, Subject, BehaviorSubject, NEVER, interval, animationFrameScheduler, combineLatest, of } from 'rxjs';\nimport { filter, switchMap, startWith, exhaustMap, takeUntil, take, map, tap, distinctUntilChanged } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Directive, Injectable, ElementRef, Component, ChangeDetectionStrategy, Inject, ContentChildren, ViewChild, Input, EventEmitter, ViewEncapsulation, Output, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n/**\r\n * IMPORTANT:\r\n * This utils are taken from the project: https://github.com/STRML/react-grid-layout.\r\n * The code should be as less modified as possible for easy maintenance.\r\n */\n\nconst _c0 = [\"resizeElem\"];\nconst _c1 = [\"*\"];\nconst DEBUG = false;\n/**\r\n * Return the bottom coordinate of the layout.\r\n *\r\n * @param  {Array} layout Layout array.\r\n * @return {Number}       Bottom coordinate.\r\n */\n\nfunction bottom(layout) {\n  let max = 0,\n      bottomY;\n\n  for (let i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n\n    if (bottomY > max) {\n      max = bottomY;\n    }\n  }\n\n  return max;\n}\n\nfunction cloneLayout(layout) {\n  const newLayout = Array(layout.length);\n\n  for (let i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n\n  return newLayout;\n} // Fast path to cloning, since this is monomorphic\n\n/** NOTE: This code has been modified from the original source */\n\n\nfunction cloneLayoutItem(layoutItem) {\n  const clonedLayoutItem = {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    id: layoutItem.id,\n    moved: !!layoutItem.moved,\n    static: !!layoutItem.static\n  };\n\n  if (layoutItem.minW !== undefined) {\n    clonedLayoutItem.minW = layoutItem.minW;\n  }\n\n  if (layoutItem.maxW !== undefined) {\n    clonedLayoutItem.maxW = layoutItem.maxW;\n  }\n\n  if (layoutItem.minH !== undefined) {\n    clonedLayoutItem.minH = layoutItem.minH;\n  }\n\n  if (layoutItem.maxH !== undefined) {\n    clonedLayoutItem.maxH = layoutItem.maxH;\n  } // These can be null\n\n\n  if (layoutItem.isDraggable !== undefined) {\n    clonedLayoutItem.isDraggable = layoutItem.isDraggable;\n  }\n\n  if (layoutItem.isResizable !== undefined) {\n    clonedLayoutItem.isResizable = layoutItem.isResizable;\n  }\n\n  return clonedLayoutItem;\n}\n/**\r\n * Given two layoutitems, check if they collide.\r\n */\n\n\nfunction collides(l1, l2) {\n  if (l1.id === l2.id) {\n    return false;\n  } // same element\n\n\n  if (l1.x + l1.w <= l2.x) {\n    return false;\n  } // l1 is left of l2\n\n\n  if (l1.x >= l2.x + l2.w) {\n    return false;\n  } // l1 is right of l2\n\n\n  if (l1.y + l1.h <= l2.y) {\n    return false;\n  } // l1 is above l2\n\n\n  if (l1.y >= l2.y + l2.h) {\n    return false;\n  } // l1 is below l2\n\n\n  return true; // boxes overlap\n}\n/**\r\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\r\n * between items.\r\n *\r\n * @param  {Array} layout Layout.\r\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\r\n *   vertically.\r\n * @return {Array}       Compacted Layout.\r\n */\n\n\nfunction compact(layout, compactType, cols) {\n  // Statics go in the compareWith array right away so items flow around them.\n  const compareWith = getStatics(layout); // We go through the items by row and column.\n\n  const sorted = sortLayoutItems(layout, compactType); // Holding for new items.\n\n  const out = Array(layout.length);\n\n  for (let i = 0, len = sorted.length; i < len; i++) {\n    let l = cloneLayoutItem(sorted[i]); // Don't move static elements\n\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted); // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n\n      compareWith.push(l);\n    } // Add to output array to make sure they still come out in the right order.\n\n\n    out[layout.indexOf(sorted[i])] = l; // Clear moved flag, if it exists.\n\n    l.moved = false;\n  }\n\n  return out;\n}\n\nconst heightWidth = {\n  x: 'w',\n  y: 'h'\n};\n/**\r\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\r\n */\n\nfunction resolveCompactionCollision(layout, item, moveToCoord, axis) {\n  const sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  const itemIndex = layout.map(layoutItem => {\n    return layoutItem.id;\n  }).indexOf(item.id); // Go through each item we collide with.\n\n  for (let i = itemIndex + 1; i < layout.length; i++) {\n    const otherItem = layout[i]; // Ignore static items\n\n    if (otherItem.static) {\n      continue;\n    } // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n\n\n    if (otherItem.y > item.y + item.h) {\n      break;\n    }\n\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n\n  item[axis] = moveToCoord;\n}\n/**\r\n * Compact an item in the layout.\r\n */\n\n\nfunction compactItem(compareWith, l, compactType, cols, fullLayout) {\n  const compactV = compactType === 'vertical';\n  const compactH = compactType === 'horizontal';\n\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y); // Move the element up as far as it can go without colliding.\n\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    l.y = Math.min(bottom(compareWith), l.y); // Move the element left as far as it can go without colliding.\n\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  } // Move it down, and keep moving it down if it's colliding.\n\n\n  let collides;\n\n  while (collides = getFirstCollision(compareWith, l)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, 'x');\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, 'y');\n    } // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n\n\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n    }\n  }\n\n  return l;\n}\n/**\r\n * Given a layout, make sure all elements fit within its bounds.\r\n *\r\n * @param  {Array} layout Layout array.\r\n * @param  {Number} bounds Number of columns.\r\n */\n\n\nfunction correctBounds(layout, bounds) {\n  const collidesWith = getStatics(layout);\n\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const l = layout[i]; // Overflows right\n\n    if (l.x + l.w > bounds.cols) {\n      l.x = bounds.cols - l.w;\n    } // Overflows left\n\n\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n\n    if (!l.static) {\n      collidesWith.push(l);\n    } else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n\n  return layout;\n}\n/**\r\n * Get a layout item by ID. Used so we can override later on if necessary.\r\n *\r\n * @param  {Array}  layout Layout array.\r\n * @param  {String} id     ID\r\n * @return {LayoutItem}    Item at ID.\r\n */\n\n\nfunction getLayoutItem(layout, id) {\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].id === id) {\n      return layout[i];\n    }\n  }\n\n  return null;\n}\n/**\r\n * Returns the first item this layout collides with.\r\n * It doesn't appear to matter which order we approach this from, although\r\n * perhaps that is the wrong thing to do.\r\n *\r\n * @param  {Object} layoutItem Layout item.\r\n * @return {Object|undefined}  A colliding layout item, or undefined.\r\n */\n\n\nfunction getFirstCollision(layout, layoutItem) {\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) {\n      return layout[i];\n    }\n  }\n\n  return null;\n}\n\nfunction getAllCollisions(layout, layoutItem) {\n  return layout.filter(l => collides(l, layoutItem));\n}\n/**\r\n * Get all static elements.\r\n * @param  {Array} layout Array of layout objects.\r\n * @return {Array}        Array of static layout items..\r\n */\n\n\nfunction getStatics(layout) {\n  return layout.filter(l => l.static);\n}\n/**\r\n * Move an element. Responsible for doing cascading movements of other elements.\r\n *\r\n * @param  {Array}      layout            Full layout to modify.\r\n * @param  {LayoutItem} l                 element to move.\r\n * @param  {Number}     [x]               X position in grid units.\r\n * @param  {Number}     [y]               Y position in grid units.\r\n */\n\n\nfunction moveElement(layout, l, x, y, isUserAction, preventCollision, compactType, cols) {\n  // If this is static and not explicitly enabled as draggable,\n  // no move is possible, so we can short-circuit this immediately.\n  if (l.static && l.isDraggable !== true) {\n    return layout;\n  } // Short-circuit if nothing to do.\n\n\n  if (l.y === y && l.x === x) {\n    return layout;\n  }\n\n  log(`Moving element ${l.id} to [${String(x)},${String(y)}] from [${l.x},${l.y}]`);\n  const oldX = l.x;\n  const oldY = l.y; // This is quite a bit faster than extending the object\n\n  if (typeof x === 'number') {\n    l.x = x;\n  }\n\n  if (typeof y === 'number') {\n    l.y = y;\n  }\n\n  l.moved = true; // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n\n  let sorted = sortLayoutItems(layout, compactType);\n  const movingUp = compactType === 'vertical' && typeof y === 'number' ? oldY >= y : compactType === 'horizontal' && typeof x === 'number' ? oldX >= x : false;\n\n  if (movingUp) {\n    sorted = sorted.reverse();\n  }\n\n  const collisions = getAllCollisions(sorted, l); // There was a collision; abort\n\n  if (preventCollision && collisions.length) {\n    log(`Collision prevented on ${l.id}, reverting.`);\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout;\n  } // Move each item that collides away from this element.\n\n\n  for (let i = 0, len = collisions.length; i < len; i++) {\n    const collision = collisions[i];\n    log(`Resolving collision between ${l.id} at [${l.x},${l.y}] and ${collision.id} at [${collision.x},${collision.y}]`); // Short circuit so we can't infinite loop\n\n    if (collision.moved) {\n      continue;\n    } // Don't move static items - we have to move *this* element away\n\n\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n\n  return layout;\n}\n/**\r\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\r\n * We attempt to move it up if there's room, otherwise it goes below.\r\n *\r\n * @param  {Array} layout            Full layout to modify.\r\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\r\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\r\n */\n\n\nfunction moveElementAwayFromCollision(layout, collidesWith, itemToMove, isUserAction, compactType, cols) {\n  const compactH = compactType === 'horizontal'; // Compact vertically if not set to horizontal\n\n  const compactV = compactType !== 'horizontal';\n  const preventCollision = collidesWith.static; // we're already colliding (not for static items)\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false; // Make a mock item so we don't modify the item here, only modify in moveElement.\n\n    const fakeItem = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      id: '-1'\n    }; // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n\n    if (!getFirstCollision(layout, fakeItem)) {\n      log(`Doing reverse collision on ${itemToMove.id} up to [${fakeItem.x},${fakeItem.y}].`);\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n/**\r\n * Helper to convert a number to a percentage string.\r\n *\r\n * @param  {Number} num Any number\r\n * @return {String}     That number as a percentage.\r\n */\n\n\nfunction perc(num) {\n  return num * 100 + '%';\n}\n\nfunction setTransform({\n  top,\n  left,\n  width,\n  height\n}) {\n  // Replace unitless items with px\n  const translate = `translate(${left}px,${top}px)`;\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: 'absolute'\n  };\n}\n\nfunction setTopLeft({\n  top,\n  left,\n  width,\n  height\n}) {\n  return {\n    top: `${top}px`,\n    left: `${left}px`,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: 'absolute'\n  };\n}\n/**\r\n * Get layout items sorted from top left to right and down.\r\n *\r\n * @return {Array} Array of layout objects.\r\n * @return {Array}        Layout, sorted static items first.\r\n */\n\n\nfunction sortLayoutItems(layout, compactType) {\n  if (compactType === 'horizontal') {\n    return sortLayoutItemsByColRow(layout);\n  } else {\n    return sortLayoutItemsByRowCol(layout);\n  }\n}\n\nfunction sortLayoutItemsByRowCol(layout) {\n  return [].concat(layout).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n\n    return -1;\n  });\n}\n\nfunction sortLayoutItemsByColRow(layout) {\n  return [].concat(layout).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n\n    return -1;\n  });\n}\n/**\r\n * Validate a layout. Throws errors.\r\n *\r\n * @param  {Array}  layout        Array of layout items.\r\n * @param  {String} [contextName] Context name for errors.\r\n * @throw  {Error}                Validation error.\r\n */\n\n\nfunction validateLayout(layout, contextName = 'Layout') {\n  const subProps = ['x', 'y', 'w', 'h'];\n\n  if (!Array.isArray(layout)) {\n    throw new Error(contextName + ' must be an array!');\n  }\n\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const item = layout[i];\n\n    for (let j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== 'number') {\n        throw new Error('ReactGridLayout: ' + contextName + '[' + i + '].' + subProps[j] + ' must be a number!');\n      }\n    }\n\n    if (item.id && typeof item.id !== 'string') {\n      throw new Error('ReactGridLayout: ' + contextName + '[' + i + '].i must be a string!');\n    }\n\n    if (item.static !== undefined && typeof item.static !== 'boolean') {\n      throw new Error('ReactGridLayout: ' + contextName + '[' + i + '].static must be a boolean!');\n    }\n  }\n} // Flow can't really figure this out, so we just use Object\n\n\nfunction autoBindHandlers(el, fns) {\n  fns.forEach(key => el[key] = el[key].bind(el));\n}\n\nfunction log(...args) {\n  if (!DEBUG) {\n    return;\n  } // eslint-disable-next-line no-console\n\n\n  console.log(...args);\n}\n\nconst noop = () => {};\n/** Cached result of whether the user's browser supports passive event listeners. */\n\n\nlet supportsPassiveEvents;\n/**\r\n * Checks whether the user's browser supports passive event listeners.\r\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\r\n */\n\nfunction ktdSupportsPassiveEventListeners() {\n  if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n    try {\n      window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\n        get: () => supportsPassiveEvents = true\n      }));\n    } finally {\n      supportsPassiveEvents = supportsPassiveEvents || false;\n    }\n  }\n\n  return supportsPassiveEvents;\n}\n/**\r\n * Normalizes an `AddEventListener` object to something that can be passed\r\n * to `addEventListener` on any browser, no matter whether it supports the\r\n * `options` parameter.\r\n * @param options Object to be normalized.\r\n */\n\n\nfunction ktdNormalizePassiveListenerOptions(options) {\n  return ktdSupportsPassiveEventListeners() ? options : !!options.capture;\n}\n/** Options that can be used to bind a passive event listener. */\n\n\nconst passiveEventListenerOptions = ktdNormalizePassiveListenerOptions({\n  passive: true\n});\n/** Options that can be used to bind an active event listener. */\n\nconst activeEventListenerOptions = ktdNormalizePassiveListenerOptions({\n  passive: false\n});\nlet isMobile = null;\n\nfunction ktdIsMobileOrTablet() {\n  if (isMobile != null) {\n    return isMobile;\n  } // Generic match pattern to identify mobile or tablet devices\n\n\n  const isMobileDevice = /Android|webOS|BlackBerry|Windows Phone|iPad|iPhone|iPod/i.test(navigator.userAgent); // Since IOS 13 is not safe to just check for the generic solution. See: https://stackoverflow.com/questions/58019463/how-to-detect-device-name-in-safari-on-ios-13-while-it-doesnt-show-the-correct\n\n  const isIOSMobileDevice = /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1;\n  isMobile = isMobileDevice || isIOSMobileDevice;\n  return isMobile;\n}\n\nfunction ktdIsMouseEvent(event) {\n  return event.clientX != null;\n}\n\nfunction ktdIsTouchEvent(event) {\n  return event.touches != null && event.touches.length != null;\n}\n\nfunction ktdPointerClientX(event) {\n  return ktdIsMouseEvent(event) ? event.clientX : event.touches[0].clientX;\n}\n\nfunction ktdPointerClientY(event) {\n  return ktdIsMouseEvent(event) ? event.clientY : event.touches[0].clientY;\n}\n\nfunction ktdPointerClient(event) {\n  return {\n    clientX: ktdIsMouseEvent(event) ? event.clientX : event.touches[0].clientX,\n    clientY: ktdIsMouseEvent(event) ? event.clientY : event.touches[0].clientY\n  };\n}\n/**\r\n * Emits when a mousedown or touchstart emits. Avoids conflicts between both events.\r\n * @param element, html element where to  listen the events.\r\n * @param touchNumber number of the touch to track the event, default to the first one.\r\n */\n\n\nfunction ktdMouseOrTouchDown(element, touchNumber = 1) {\n  return iif(() => ktdIsMobileOrTablet(), fromEvent(element, 'touchstart', passiveEventListenerOptions).pipe(filter(touchEvent => touchEvent.touches.length === touchNumber)), fromEvent(element, 'mousedown', activeEventListenerOptions).pipe(filter(mouseEvent => {\n    /**\r\n     * 0 : Left mouse button\r\n     * 1 : Wheel button or middle button (if present)\r\n     * 2 : Right mouse button\r\n     */\n    return mouseEvent.button === 0; // Mouse down to be only fired if is left click\n  })));\n}\n/**\r\n * Emits when a 'mousemove' or a 'touchmove' event gets fired.\r\n * @param element, html element where to  listen the events.\r\n * @param touchNumber number of the touch to track the event, default to the first one.\r\n */\n\n\nfunction ktdMouseOrTouchMove(element, touchNumber = 1) {\n  return iif(() => ktdIsMobileOrTablet(), fromEvent(element, 'touchmove', activeEventListenerOptions).pipe(filter(touchEvent => touchEvent.touches.length === touchNumber)), fromEvent(element, 'mousemove', activeEventListenerOptions));\n}\n\nfunction ktdTouchEnd(element, touchNumber = 1) {\n  return merge(fromEvent(element, 'touchend').pipe(filter(touchEvent => touchEvent.touches.length === touchNumber - 1)), fromEvent(element, 'touchcancel').pipe(filter(touchEvent => touchEvent.touches.length === touchNumber - 1)));\n}\n/**\r\n * Emits when a there is a 'mouseup' or the touch ends.\r\n * @param element, html element where to  listen the events.\r\n * @param touchNumber number of the touch to track the event, default to the first one.\r\n */\n\n\nfunction ktdMouseOrTouchEnd(element, touchNumber = 1) {\n  return iif(() => ktdIsMobileOrTablet(), ktdTouchEnd(element, touchNumber), fromEvent(element, 'mouseup'));\n}\n/** Tracks items by id. This function is mean to be used in conjunction with the ngFor that renders the 'ktd-grid-items' */\n\n\nfunction ktdTrackById(index, item) {\n  return item.id;\n}\n/**\r\n * Call react-grid-layout utils 'compact()' function and return the compacted layout.\r\n * @param layout to be compacted.\r\n * @param compactType, type of compaction.\r\n * @param cols, number of columns of the grid.\r\n */\n\n\nfunction ktdGridCompact(layout, compactType, cols) {\n  return compact(layout, compactType, cols) // Prune react-grid-layout compact extra properties.\n  .map(item => ({\n    id: item.id,\n    x: item.x,\n    y: item.y,\n    w: item.w,\n    h: item.h,\n    minW: item.minW,\n    minH: item.minH,\n    maxW: item.maxW,\n    maxH: item.maxH\n  }));\n}\n\nfunction screenXPosToGridValue(screenXPos, cols, width) {\n  return Math.round(screenXPos * cols / width);\n}\n\nfunction screenYPosToGridValue(screenYPos, rowHeight, height) {\n  return Math.round(screenYPos / rowHeight);\n}\n/** Returns a Dictionary where the key is the id and the value is the change applied to that item. If no changes Dictionary is empty. */\n\n\nfunction ktdGetGridLayoutDiff(gridLayoutA, gridLayoutB) {\n  const diff = {};\n  gridLayoutA.forEach(itemA => {\n    const itemB = gridLayoutB.find(_itemB => _itemB.id === itemA.id);\n\n    if (itemB != null) {\n      const posChanged = itemA.x !== itemB.x || itemA.y !== itemB.y;\n      const sizeChanged = itemA.w !== itemB.w || itemA.h !== itemB.h;\n      const change = posChanged && sizeChanged ? 'moveresize' : posChanged ? 'move' : sizeChanged ? 'resize' : null;\n\n      if (change) {\n        diff[itemB.id] = {\n          change\n        };\n      }\n    }\n  });\n  return diff;\n}\n/**\r\n * Given the grid config & layout data and the current drag position & information, returns the corresponding layout and drag item position\r\n * @param gridItem grid item that is been dragged\r\n * @param config current grid configuration\r\n * @param compactionType type of compaction that will be performed\r\n * @param draggingData contains all the information about the drag\r\n */\n\n\nfunction ktdGridItemDragging(gridItem, config, compactionType, draggingData) {\n  const {\n    pointerDownEvent,\n    pointerDragEvent,\n    gridElemClientRect,\n    dragElemClientRect,\n    scrollDifference\n  } = draggingData;\n  const gridItemId = gridItem.id;\n  const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId);\n  const clientStartX = ktdPointerClientX(pointerDownEvent);\n  const clientStartY = ktdPointerClientY(pointerDownEvent);\n  const clientX = ktdPointerClientX(pointerDragEvent);\n  const clientY = ktdPointerClientY(pointerDragEvent);\n  const offsetX = clientStartX - dragElemClientRect.left;\n  const offsetY = clientStartY - dragElemClientRect.top; // Grid element positions taking into account the possible scroll total difference from the beginning.\n\n  const gridElementLeftPosition = gridElemClientRect.left + scrollDifference.left;\n  const gridElementTopPosition = gridElemClientRect.top + scrollDifference.top; // Calculate position relative to the grid element.\n\n  const gridRelXPos = clientX - gridElementLeftPosition - offsetX;\n  const gridRelYPos = clientY - gridElementTopPosition - offsetY; // Get layout item position\n\n  const layoutItem = Object.assign(Object.assign({}, draggingElemPrevItem), {\n    x: screenXPosToGridValue(gridRelXPos, config.cols, gridElemClientRect.width),\n    y: screenYPosToGridValue(gridRelYPos, config.rowHeight, gridElemClientRect.height)\n  }); // Correct the values if they overflow, since 'moveElement' function doesn't do it\n\n  layoutItem.x = Math.max(0, layoutItem.x);\n  layoutItem.y = Math.max(0, layoutItem.y);\n\n  if (layoutItem.x + layoutItem.w > config.cols) {\n    layoutItem.x = Math.max(0, config.cols - layoutItem.w);\n  } // Parse to LayoutItem array data in order to use 'react.grid-layout' utils\n\n\n  const layoutItems = config.layout;\n  const draggedLayoutItem = layoutItems.find(item => item.id === gridItemId);\n  let newLayoutItems = moveElement(layoutItems, draggedLayoutItem, layoutItem.x, layoutItem.y, true, config.preventCollision, compactionType, config.cols);\n  newLayoutItems = compact(newLayoutItems, compactionType, config.cols);\n  return {\n    layout: newLayoutItems,\n    draggedItemPos: {\n      top: gridRelYPos,\n      left: gridRelXPos,\n      width: dragElemClientRect.width,\n      height: dragElemClientRect.height\n    }\n  };\n}\n/**\r\n * Given the grid config & layout data and the current drag position & information, returns the corresponding layout and drag item position\r\n * @param gridItem grid item that is been dragged\r\n * @param config current grid configuration\r\n * @param compactionType type of compaction that will be performed\r\n * @param draggingData contains all the information about the drag\r\n */\n\n\nfunction ktdGridItemResizing(gridItem, config, compactionType, draggingData) {\n  var _a, _b, _c, _d;\n\n  const {\n    pointerDownEvent,\n    pointerDragEvent,\n    gridElemClientRect,\n    dragElemClientRect,\n    scrollDifference\n  } = draggingData;\n  const gridItemId = gridItem.id;\n  const clientStartX = ktdPointerClientX(pointerDownEvent);\n  const clientStartY = ktdPointerClientY(pointerDownEvent);\n  const clientX = ktdPointerClientX(pointerDragEvent);\n  const clientY = ktdPointerClientY(pointerDragEvent); // Get the difference between the mouseDown and the position 'right' of the resize element.\n\n  const resizeElemOffsetX = dragElemClientRect.width - (clientStartX - dragElemClientRect.left);\n  const resizeElemOffsetY = dragElemClientRect.height - (clientStartY - dragElemClientRect.top);\n  const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId);\n  const width = clientX + resizeElemOffsetX - (dragElemClientRect.left + scrollDifference.left);\n  const height = clientY + resizeElemOffsetY - (dragElemClientRect.top + scrollDifference.top); // Get layout item grid position\n\n  const layoutItem = Object.assign(Object.assign({}, draggingElemPrevItem), {\n    w: screenXPosToGridValue(width, config.cols, gridElemClientRect.width),\n    h: screenYPosToGridValue(height, config.rowHeight, gridElemClientRect.height)\n  });\n  layoutItem.w = limitNumberWithinRange(layoutItem.w, (_a = gridItem.minW) !== null && _a !== void 0 ? _a : layoutItem.minW, (_b = gridItem.maxW) !== null && _b !== void 0 ? _b : layoutItem.maxW);\n  layoutItem.h = limitNumberWithinRange(layoutItem.h, (_c = gridItem.minH) !== null && _c !== void 0 ? _c : layoutItem.minH, (_d = gridItem.maxH) !== null && _d !== void 0 ? _d : layoutItem.maxH);\n\n  if (layoutItem.x + layoutItem.w > config.cols) {\n    layoutItem.w = Math.max(1, config.cols - layoutItem.x);\n  }\n\n  if (config.preventCollision) {\n    const maxW = layoutItem.w;\n    const maxH = layoutItem.h;\n    let colliding = hasCollision(config.layout, layoutItem);\n    let shrunkDimension;\n\n    while (colliding) {\n      shrunkDimension = getDimensionToShrink(layoutItem, shrunkDimension);\n      layoutItem[shrunkDimension]--;\n      colliding = hasCollision(config.layout, layoutItem);\n    }\n\n    if (shrunkDimension === 'w') {\n      layoutItem.h = maxH;\n      colliding = hasCollision(config.layout, layoutItem);\n\n      while (colliding) {\n        layoutItem.h--;\n        colliding = hasCollision(config.layout, layoutItem);\n      }\n    }\n\n    if (shrunkDimension === 'h') {\n      layoutItem.w = maxW;\n      colliding = hasCollision(config.layout, layoutItem);\n\n      while (colliding) {\n        layoutItem.w--;\n        colliding = hasCollision(config.layout, layoutItem);\n      }\n    }\n  }\n\n  const newLayoutItems = config.layout.map(item => {\n    return item.id === gridItemId ? layoutItem : item;\n  });\n  return {\n    layout: compact(newLayoutItems, compactionType, config.cols),\n    draggedItemPos: {\n      top: dragElemClientRect.top - gridElemClientRect.top,\n      left: dragElemClientRect.left - gridElemClientRect.left,\n      width,\n      height\n    }\n  };\n}\n\nfunction hasCollision(layout, layoutItem) {\n  return !!getFirstCollision(layout, layoutItem);\n}\n\nfunction getDimensionToShrink(layoutItem, lastShrunk) {\n  if (layoutItem.h <= 1) {\n    return 'w';\n  }\n\n  if (layoutItem.w <= 1) {\n    return 'h';\n  }\n\n  return lastShrunk === 'w' ? 'h' : 'w';\n}\n/**\r\n * Given the current number and min/max values, returns the number within the range\r\n * @param number can be any numeric value\r\n * @param min minimum value of range\r\n * @param max maximum value of range\r\n */\n\n\nfunction limitNumberWithinRange(num, min = 1, max = Infinity) {\n  return Math.min(Math.max(num, min < 1 ? 1 : min), max);\n}\n/**\r\n * Injection token that can be used to reference instances of `KtdGridDragHandle`. It serves as\r\n * alternative token to the actual `KtdGridDragHandle` class which could cause unnecessary\r\n * retention of the class and its directive metadata.\r\n */\n\n\nconst KTD_GRID_DRAG_HANDLE = new InjectionToken('KtdGridDragHandle');\n/** Handle that can be used to drag a KtdGridItem instance. */\n// tslint:disable-next-line:directive-class-suffix\n\nlet KtdGridDragHandle = /*#__PURE__*/(() => {\n  class KtdGridDragHandle {\n    constructor(element) {\n      this.element = element;\n    }\n\n  }\n\n  KtdGridDragHandle.ɵfac = function KtdGridDragHandle_Factory(t) {\n    return new (t || KtdGridDragHandle)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  KtdGridDragHandle.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: KtdGridDragHandle,\n    selectors: [[\"\", \"ktdGridDragHandle\", \"\"]],\n    hostAttrs: [1, \"ktd-grid-drag-handle\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: KTD_GRID_DRAG_HANDLE,\n      useExisting: KtdGridDragHandle\n    }])]\n  });\n  return KtdGridDragHandle;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * Injection token that can be used to reference instances of `KtdGridResizeHandle`. It serves as\r\n * alternative token to the actual `KtdGridResizeHandle` class which could cause unnecessary\r\n * retention of the class and its directive metadata.\r\n */\n\n\nconst KTD_GRID_RESIZE_HANDLE = new InjectionToken('KtdGridResizeHandle');\n/** Handle that can be used to drag a KtdGridItem instance. */\n\nlet KtdGridResizeHandle = /*#__PURE__*/(() => {\n  class KtdGridResizeHandle {\n    constructor(element) {\n      this.element = element;\n    }\n\n  }\n\n  KtdGridResizeHandle.ɵfac = function KtdGridResizeHandle_Factory(t) {\n    return new (t || KtdGridResizeHandle)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  KtdGridResizeHandle.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: KtdGridResizeHandle,\n    selectors: [[\"\", \"ktdGridResizeHandle\", \"\"]],\n    hostAttrs: [1, \"ktd-grid-resize-handle\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: KTD_GRID_RESIZE_HANDLE,\n      useExisting: KtdGridResizeHandle\n    }])]\n  });\n  return KtdGridResizeHandle;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst GRID_ITEM_GET_RENDER_DATA_TOKEN = new InjectionToken('GRID_ITEM_GET_RENDER_DATA_TOKEN');\n/** Runs source observable outside the zone */\n\nfunction ktdOutsideZone(zone) {\n  return source => {\n    return new Observable(observer => {\n      return zone.runOutsideAngular(() => source.subscribe(observer));\n    });\n  };\n}\n/** Rxjs operator that makes source observable to no emit any data */\n\n\nfunction ktdNoEmit() {\n  return source$ => {\n    return source$.pipe(filter(() => false));\n  };\n}\n/** Coerces a data-bound value (typically a string) to a boolean. */\n\n\nfunction coerceBooleanProperty(value) {\n  return value != null && `${value}` !== 'false';\n}\n\nfunction coerceNumberProperty(value, fallbackValue = 0) {\n  return _isNumberValue(value) ? Number(value) : fallbackValue;\n}\n/**\r\n * Whether the provided value is considered a number.\r\n * @docs-private\r\n */\n\n\nfunction _isNumberValue(value) {\n  // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n  // and other non-number values as NaN, where Number just uses 0) but it considers the string\n  // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n  return !isNaN(parseFloat(value)) && !isNaN(Number(value));\n}\n/** Event options that can be used to bind an active, capturing event. */\n\n\nconst activeCapturingEventOptions = ktdNormalizePassiveListenerOptions({\n  passive: false,\n  capture: true\n});\nlet KtdGridService = /*#__PURE__*/(() => {\n  class KtdGridService {\n    constructor(ngZone) {\n      this.ngZone = ngZone;\n      this.touchMoveSubject = new Subject();\n      this.touchMove$ = this.touchMoveSubject.asObservable();\n      this.registerTouchMoveSubscription();\n    }\n\n    ngOnDestroy() {\n      this.touchMoveSubscription.unsubscribe();\n    }\n\n    mouseOrTouchMove$(element) {\n      return iif(() => ktdIsMobileOrTablet(), this.touchMove$, fromEvent(element, 'mousemove', activeCapturingEventOptions) // TODO: Fix rxjs typings, boolean should be a good param too.\n      );\n    }\n\n    registerTouchMoveSubscription() {\n      // The `touchmove` event gets bound once, ahead of time, because WebKit\n      // won't preventDefault on a dynamically-added `touchmove` listener.\n      // See https://bugs.webkit.org/show_bug.cgi?id=184250.\n      this.touchMoveSubscription = this.ngZone.runOutsideAngular(() => // The event handler has to be explicitly active,\n      // because newer browsers make it passive by default.\n      fromEvent(document, 'touchmove', activeCapturingEventOptions) // TODO: Fix rxjs typings, boolean should be a good param too.\n      .pipe(filter(touchEvent => touchEvent.touches.length === 1)).subscribe(touchEvent => this.touchMoveSubject.next(touchEvent)));\n    }\n\n  }\n\n  KtdGridService.ɵfac = function KtdGridService_Factory(t) {\n    return new (t || KtdGridService)(i0.ɵɵinject(i0.NgZone));\n  };\n\n  KtdGridService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: KtdGridService,\n    factory: KtdGridService.ɵfac,\n    providedIn: 'root'\n  });\n  return KtdGridService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet KtdGridItemComponent = /*#__PURE__*/(() => {\n  class KtdGridItemComponent {\n    constructor(elementRef, gridService, renderer, ngZone, getItemRenderData) {\n      this.elementRef = elementRef;\n      this.gridService = gridService;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.getItemRenderData = getItemRenderData;\n      /** CSS transition style. Note that for more performance is preferable only make transition on transform property. */\n\n      this.transition = 'transform 500ms ease, width 500ms ease, height 500ms ease';\n      this._dragStartThreshold = 0;\n      this._draggable = true;\n      this._draggable$ = new BehaviorSubject(this._draggable);\n      this._resizable = true;\n      this._resizable$ = new BehaviorSubject(this._resizable);\n      this.dragStartSubject = new Subject();\n      this.resizeStartSubject = new Subject();\n      this.subscriptions = [];\n      this.dragStart$ = this.dragStartSubject.asObservable();\n      this.resizeStart$ = this.resizeStartSubject.asObservable();\n    }\n    /** Id of the grid item. This property is strictly compulsory. */\n\n\n    get id() {\n      return this._id;\n    }\n\n    set id(val) {\n      this._id = val;\n    }\n    /** Minimum amount of pixels that the user should move before it starts the drag sequence. */\n\n\n    get dragStartThreshold() {\n      return this._dragStartThreshold;\n    }\n\n    set dragStartThreshold(val) {\n      this._dragStartThreshold = coerceNumberProperty(val);\n    }\n    /** Whether the item is draggable or not. Defaults to true. */\n\n\n    get draggable() {\n      return this._draggable;\n    }\n\n    set draggable(val) {\n      this._draggable = coerceBooleanProperty(val);\n\n      this._draggable$.next(this._draggable);\n    }\n    /** Whether the item is resizable or not. Defaults to true. */\n\n\n    get resizable() {\n      return this._resizable;\n    }\n\n    set resizable(val) {\n      this._resizable = coerceBooleanProperty(val);\n\n      this._resizable$.next(this._resizable);\n    }\n\n    ngOnInit() {\n      const gridItemRenderData = this.getItemRenderData(this.id);\n      this.setStyles(gridItemRenderData);\n    }\n\n    ngAfterContentInit() {\n      this.subscriptions.push(this._dragStart$().subscribe(this.dragStartSubject), this._resizeStart$().subscribe(this.resizeStartSubject));\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(sub => sub.unsubscribe());\n    }\n\n    setStyles({\n      top,\n      left,\n      width,\n      height\n    }) {\n      // transform is 6x times faster than top/left\n      this.renderer.setStyle(this.elementRef.nativeElement, 'transform', `translateX(${left}) translateY(${top})`);\n      this.renderer.setStyle(this.elementRef.nativeElement, 'display', `block`);\n      this.renderer.setStyle(this.elementRef.nativeElement, 'transition', this.transition);\n\n      if (width != null) {\n        this.renderer.setStyle(this.elementRef.nativeElement, 'width', width);\n      }\n\n      if (height != null) {\n        this.renderer.setStyle(this.elementRef.nativeElement, 'height', height);\n      }\n    }\n\n    _dragStart$() {\n      return this._draggable$.pipe(switchMap(draggable => {\n        if (!draggable) {\n          return NEVER;\n        } else {\n          return this._dragHandles.changes.pipe(startWith(this._dragHandles), switchMap(dragHandles => {\n            return iif(() => dragHandles.length > 0, merge(...dragHandles.toArray().map(dragHandle => ktdMouseOrTouchDown(dragHandle.element.nativeElement, 1))), ktdMouseOrTouchDown(this.elementRef.nativeElement, 1)).pipe(exhaustMap(startEvent => {\n              // If the event started from an element with the native HTML drag&drop, it'll interfere\n              // with our own dragging (e.g. `img` tags do it by default). Prevent the default action\n              // to stop it from happening. Note that preventing on `dragstart` also seems to work, but\n              // it's flaky and it fails if the user drags it away quickly. Also note that we only want\n              // to do this for `mousedown` since doing the same for `touchstart` will stop any `click`\n              // events from firing on touch devices.\n              if (startEvent.target && startEvent.target.draggable && startEvent.type === 'mousedown') {\n                startEvent.preventDefault();\n              }\n\n              const startPointer = ktdPointerClient(startEvent);\n              return this.gridService.mouseOrTouchMove$(document).pipe(takeUntil(ktdMouseOrTouchEnd(document, 1)), ktdOutsideZone(this.ngZone), filter(moveEvent => {\n                moveEvent.preventDefault();\n                const movePointer = ktdPointerClient(moveEvent);\n                const distanceX = Math.abs(startPointer.clientX - movePointer.clientX);\n                const distanceY = Math.abs(startPointer.clientY - movePointer.clientY); // When this conditions returns true mean that we are over threshold.\n\n                return distanceX + distanceY >= this.dragStartThreshold;\n              }), take(1), // Return the original start event\n              map(() => startEvent));\n            }));\n          }));\n        }\n      }));\n    }\n\n    _resizeStart$() {\n      return this._resizable$.pipe(switchMap(resizable => {\n        if (!resizable) {\n          // Side effect to hide the resizeElem if resize is disabled.\n          this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'none');\n          return NEVER;\n        } else {\n          return this._resizeHandles.changes.pipe(startWith(this._resizeHandles), switchMap(resizeHandles => {\n            if (resizeHandles.length > 0) {\n              // Side effect to hide the resizeElem if there are resize handles.\n              this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'none');\n              return merge(...resizeHandles.toArray().map(resizeHandle => ktdMouseOrTouchDown(resizeHandle.element.nativeElement, 1)));\n            } else {\n              this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'block');\n              return ktdMouseOrTouchDown(this.resizeElem.nativeElement, 1);\n            }\n          }));\n        }\n      }));\n    }\n\n  }\n\n  KtdGridItemComponent.ɵfac = function KtdGridItemComponent_Factory(t) {\n    return new (t || KtdGridItemComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(KtdGridService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(GRID_ITEM_GET_RENDER_DATA_TOKEN));\n  };\n\n  KtdGridItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: KtdGridItemComponent,\n    selectors: [[\"ktd-grid-item\"]],\n    contentQueries: function KtdGridItemComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, KTD_GRID_DRAG_HANDLE, 5);\n        i0.ɵɵcontentQuery(dirIndex, KTD_GRID_RESIZE_HANDLE, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._dragHandles = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._resizeHandles = _t);\n      }\n    },\n    viewQuery: function KtdGridItemComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7, ElementRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.resizeElem = _t.first);\n      }\n    },\n    inputs: {\n      minW: \"minW\",\n      minH: \"minH\",\n      maxW: \"maxW\",\n      maxH: \"maxH\",\n      transition: \"transition\",\n      id: \"id\",\n      dragStartThreshold: \"dragStartThreshold\",\n      draggable: \"draggable\",\n      resizable: \"resizable\"\n    },\n    ngContentSelectors: _c1,\n    decls: 3,\n    vars: 0,\n    consts: [[1, \"grid-item-resize-icon\"], [\"resizeElem\", \"\"]],\n    template: function KtdGridItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n        i0.ɵɵelement(1, \"div\", 0, 1);\n      }\n    },\n    styles: [\"[_nghost-%COMP%]{display:none;position:absolute;z-index:1;overflow:hidden}[_nghost-%COMP%]   div[_ngcontent-%COMP%]{position:absolute;-webkit-user-select:none;user-select:none;z-index:10}[_nghost-%COMP%]   div.grid-item-resize-icon[_ngcontent-%COMP%]{cursor:se-resize;width:20px;height:20px;bottom:0;right:0;color:inherit}[_nghost-%COMP%]   div.grid-item-resize-icon[_ngcontent-%COMP%]:after{content:\\\"\\\";position:absolute;right:3px;bottom:3px;width:5px;height:5px;border-right:2px solid;border-bottom:2px solid}.display-none[_ngcontent-%COMP%]{display:none!important}\"],\n    changeDetection: 0\n  });\n  return KtdGridItemComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable\n\n/**\r\n * Client rect utilities.\r\n * This file is taken from Angular Material repository. This is the reason why the tslint is disabled on this case.\r\n * Don't enable it until some custom change is done on this file.\r\n */\n\n/** Gets a mutable version of an element's bounding `ClientRect`. */\n\n\nfunction getMutableClientRect(element) {\n  const clientRect = element.getBoundingClientRect(); // We need to clone the `clientRect` here, because all the values on it are readonly\n  // and we need to be able to update them. Also we can't use a spread here, because\n  // the values on a `ClientRect` aren't own properties. See:\n  // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\n\n  return {\n    top: clientRect.top,\n    right: clientRect.right,\n    bottom: clientRect.bottom,\n    left: clientRect.left,\n    width: clientRect.width,\n    height: clientRect.height\n  };\n}\n/**\r\n * Checks whether some coordinates are within a `ClientRect`.\r\n * @param clientRect ClientRect that is being checked.\r\n * @param x Coordinates along the X axis.\r\n * @param y Coordinates along the Y axis.\r\n */\n\n\nfunction isInsideClientRect(clientRect, x, y) {\n  const {\n    top,\n    bottom,\n    left,\n    right\n  } = clientRect;\n  return y >= top && y <= bottom && x >= left && x <= right;\n}\n/**\r\n * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\r\n * @param clientRect `ClientRect` that should be updated.\r\n * @param top Amount to add to the `top` position.\r\n * @param left Amount to add to the `left` position.\r\n */\n\n\nfunction adjustClientRect(clientRect, top, left) {\n  clientRect.top += top;\n  clientRect.bottom = clientRect.top + clientRect.height;\n  clientRect.left += left;\n  clientRect.right = clientRect.left + clientRect.width;\n}\n/**\r\n * Checks whether the pointer coordinates are close to a ClientRect.\r\n * @param rect ClientRect to check against.\r\n * @param threshold Threshold around the ClientRect.\r\n * @param pointerX Coordinates along the X axis.\r\n * @param pointerY Coordinates along the Y axis.\r\n */\n\n\nfunction isPointerNearClientRect(rect, threshold, pointerX, pointerY) {\n  const {\n    top,\n    right,\n    bottom,\n    left,\n    width,\n    height\n  } = rect;\n  const xThreshold = width * threshold;\n  const yThreshold = height * threshold;\n  return pointerY > top - yThreshold && pointerY < bottom + yThreshold && pointerX > left - xThreshold && pointerX < right + xThreshold;\n}\n/**\r\n * Proximity, as a ratio to width/height at which to start auto-scrolling.\r\n * The value comes from trying it out manually until it feels right.\r\n */\n\n\nconst SCROLL_PROXIMITY_THRESHOLD = 0.05;\n/**\r\n * Increments the vertical scroll position of a node.\r\n * @param node Node whose scroll position should change.\r\n * @param amount Amount of pixels that the `node` should be scrolled.\r\n */\n\nfunction incrementVerticalScroll(node, amount) {\n  if (node === window) {\n    node.scrollBy(0, amount);\n  } else {\n    // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n    node.scrollTop += amount;\n  }\n}\n/**\r\n * Increments the horizontal scroll position of a node.\r\n * @param node Node whose scroll position should change.\r\n * @param amount Amount of pixels that the `node` should be scrolled.\r\n */\n\n\nfunction incrementHorizontalScroll(node, amount) {\n  if (node === window) {\n    node.scrollBy(amount, 0);\n  } else {\n    // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n    node.scrollLeft += amount;\n  }\n}\n/**\r\n * Gets whether the vertical auto-scroll direction of a node.\r\n * @param clientRect Dimensions of the node.\r\n * @param pointerY Position of the user's pointer along the y axis.\r\n */\n\n\nfunction getVerticalScrollDirection(clientRect, pointerY) {\n  const {\n    top,\n    bottom,\n    height\n  } = clientRect;\n  const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;\n\n  if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {\n    return 1\n    /* UP */\n    ;\n  } else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {\n    return 2\n    /* DOWN */\n    ;\n  }\n\n  return 0\n  /* NONE */\n  ;\n}\n/**\r\n * Gets whether the horizontal auto-scroll direction of a node.\r\n * @param clientRect Dimensions of the node.\r\n * @param pointerX Position of the user's pointer along the x axis.\r\n */\n\n\nfunction getHorizontalScrollDirection(clientRect, pointerX) {\n  const {\n    left,\n    right,\n    width\n  } = clientRect;\n  const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;\n\n  if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {\n    return 1\n    /* LEFT */\n    ;\n  } else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {\n    return 2\n    /* RIGHT */\n    ;\n  }\n\n  return 0\n  /* NONE */\n  ;\n}\n/**\r\n * Returns an observable that schedules a loop and apply scroll on the scrollNode into the specified direction/s.\r\n * This observable doesn't emit, it just performs the 'scroll' side effect.\r\n * @param scrollNode, node where the scroll would be applied.\r\n * @param verticalScrollDirection, vertical direction of the scroll.\r\n * @param horizontalScrollDirection, horizontal direction of the scroll.\r\n * @param scrollStep, scroll step in CSS pixels that would be applied in every loop.\r\n */\n\n\nfunction scrollToDirectionInterval$(scrollNode, verticalScrollDirection, horizontalScrollDirection, scrollStep = 2) {\n  return interval(0, animationFrameScheduler).pipe(tap(() => {\n    if (verticalScrollDirection === 1\n    /* UP */\n    ) {\n      incrementVerticalScroll(scrollNode, -scrollStep);\n    } else if (verticalScrollDirection === 2\n    /* DOWN */\n    ) {\n      incrementVerticalScroll(scrollNode, scrollStep);\n    }\n\n    if (horizontalScrollDirection === 1\n    /* LEFT */\n    ) {\n      incrementHorizontalScroll(scrollNode, -scrollStep);\n    } else if (horizontalScrollDirection === 2\n    /* RIGHT */\n    ) {\n      incrementHorizontalScroll(scrollNode, scrollStep);\n    }\n  }), ktdNoEmit());\n}\n/**\r\n * Given a source$ observable with pointer location, scroll the scrollNode if the pointer is near to it.\r\n * This observable doesn't emit, it just performs a 'scroll' side effect.\r\n * @param scrollableParent, parent node in which the scroll would be performed.\r\n * @param options, configuration options.\r\n */\n\n\nfunction ktdScrollIfNearElementClientRect$(scrollableParent, options) {\n  let scrollNode;\n  let scrollableParentClientRect;\n  let scrollableParentScrollWidth;\n\n  if (scrollableParent === document) {\n    scrollNode = document.defaultView;\n    const {\n      width,\n      height\n    } = getViewportSize();\n    scrollableParentClientRect = {\n      width,\n      height,\n      top: 0,\n      right: width,\n      bottom: height,\n      left: 0\n    };\n    scrollableParentScrollWidth = getDocumentScrollWidth();\n  } else {\n    scrollNode = scrollableParent;\n    scrollableParentClientRect = getMutableClientRect(scrollableParent);\n    scrollableParentScrollWidth = scrollableParent.scrollWidth;\n  }\n  /**\r\n   * IMPORTANT: By design, only let scroll horizontal if the scrollable parent has explicitly an scroll horizontal.\r\n   * This layout solution is not designed in mind to have any scroll horizontal, but exceptionally we allow it in this\r\n   * specific use case.\r\n   */\n\n\n  options = options || {};\n\n  if (options.disableHorizontal == null && scrollableParentScrollWidth <= scrollableParentClientRect.width) {\n    options.disableHorizontal = true;\n  }\n\n  return source$ => source$.pipe(map(({\n    pointerX,\n    pointerY\n  }) => {\n    let verticalScrollDirection = getVerticalScrollDirection(scrollableParentClientRect, pointerY);\n    let horizontalScrollDirection = getHorizontalScrollDirection(scrollableParentClientRect, pointerX); // Check if scroll directions are disabled.\n\n    if (options === null || options === void 0 ? void 0 : options.disableVertical) {\n      verticalScrollDirection = 0\n      /* NONE */\n      ;\n    }\n\n    if (options === null || options === void 0 ? void 0 : options.disableHorizontal) {\n      horizontalScrollDirection = 0\n      /* NONE */\n      ;\n    }\n\n    return {\n      verticalScrollDirection,\n      horizontalScrollDirection\n    };\n  }), distinctUntilChanged((prev, actual) => {\n    return prev.verticalScrollDirection === actual.verticalScrollDirection && prev.horizontalScrollDirection === actual.horizontalScrollDirection;\n  }), switchMap(({\n    verticalScrollDirection,\n    horizontalScrollDirection\n  }) => {\n    if (verticalScrollDirection || horizontalScrollDirection) {\n      return scrollToDirectionInterval$(scrollNode, verticalScrollDirection, horizontalScrollDirection, options === null || options === void 0 ? void 0 : options.scrollStep);\n    } else {\n      return NEVER;\n    }\n  }));\n}\n/**\r\n * Emits on EVERY scroll event and returns the accumulated scroll offset relative to the initial scroll position.\r\n * @param scrollableParent, node in which scroll events would be listened.\r\n */\n\n\nfunction ktdGetScrollTotalRelativeDifference$(scrollableParent) {\n  let scrollInitialPosition; // Calculate initial scroll position\n\n  if (scrollableParent === document) {\n    scrollInitialPosition = getViewportScrollPosition();\n  } else {\n    scrollInitialPosition = {\n      top: scrollableParent.scrollTop,\n      left: scrollableParent.scrollLeft\n    };\n  }\n\n  return fromEvent(scrollableParent, 'scroll', ktdNormalizePassiveListenerOptions({\n    capture: true\n  })).pipe(map(() => {\n    let newTop;\n    let newLeft;\n\n    if (scrollableParent === document) {\n      const viewportScrollPosition = getViewportScrollPosition();\n      newTop = viewportScrollPosition.top;\n      newLeft = viewportScrollPosition.left;\n    } else {\n      newTop = scrollableParent.scrollTop;\n      newLeft = scrollableParent.scrollLeft;\n    }\n\n    const topDifference = scrollInitialPosition.top - newTop;\n    const leftDifference = scrollInitialPosition.left - newLeft;\n    return {\n      top: topDifference,\n      left: leftDifference\n    };\n  }));\n}\n/** Returns the viewport's width and height. */\n\n\nfunction getViewportSize() {\n  const _window = document.defaultView || window;\n\n  return {\n    width: _window.innerWidth,\n    height: _window.innerHeight\n  };\n}\n/** Gets a ClientRect for the viewport's bounds. */\n\n\nfunction getViewportRect() {\n  // Use the document element's bounding rect rather than the window scroll properties\n  // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n  // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n  // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n  // can disagree when the page is pinch-zoomed (on devices that support touch).\n  // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n  // We use the documentElement instead of the body because, by default (without a css reset)\n  // browsers typically give the document body an 8px margin, which is not included in\n  // getBoundingClientRect().\n  const scrollPosition = getViewportScrollPosition();\n  const {\n    width,\n    height\n  } = getViewportSize();\n  return {\n    top: scrollPosition.top,\n    left: scrollPosition.left,\n    bottom: scrollPosition.top + height,\n    right: scrollPosition.left + width,\n    height,\n    width\n  };\n}\n/** Gets the (top, left) scroll position of the viewport. */\n\n\nfunction getViewportScrollPosition() {\n  // The top-left-corner of the viewport is determined by the scroll position of the document\n  // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n  // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n  // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n  // `document.documentElement` works consistently, where the `top` and `left` values will\n  // equal negative the scroll position.\n  const windowRef = document.defaultView || window;\n  const documentElement = document.documentElement;\n  const documentRect = documentElement.getBoundingClientRect();\n  const top = -documentRect.top || document.body.scrollTop || windowRef.scrollY || documentElement.scrollTop || 0;\n  const left = -documentRect.left || document.body.scrollLeft || windowRef.scrollX || documentElement.scrollLeft || 0;\n  return {\n    top,\n    left\n  };\n}\n/** Returns the document scroll width */\n\n\nfunction getDocumentScrollWidth() {\n  return Math.max(document.body.scrollWidth, document.documentElement.scrollWidth);\n}\n\nfunction getDragResizeEventData(gridItem, layout) {\n  return {\n    layout,\n    layoutItem: layout.find(item => item.id === gridItem.id),\n    gridItemRef: gridItem\n  };\n}\n\nfunction layoutToRenderItems(config, width, height) {\n  const {\n    cols,\n    rowHeight,\n    layout\n  } = config;\n  const renderItems = {};\n\n  for (const item of layout) {\n    renderItems[item.id] = {\n      id: item.id,\n      top: item.y === 0 ? 0 : item.y * rowHeight,\n      left: item.x * (width / cols),\n      width: item.w * (width / cols),\n      height: item.h * rowHeight\n    };\n  }\n\n  return renderItems;\n}\n\nfunction getGridHeight(layout, rowHeight) {\n  return layout.reduce((acc, cur) => Math.max(acc, (cur.y + cur.h) * rowHeight), 0);\n} // tslint:disable-next-line\n\n\nfunction parseRenderItemToPixels(renderItem) {\n  return {\n    id: renderItem.id,\n    top: `${renderItem.top}px`,\n    left: `${renderItem.left}px`,\n    width: `${renderItem.width}px`,\n    height: `${renderItem.height}px`\n  };\n} // tslint:disable-next-line:ktd-prefix-code\n\n\nfunction __gridItemGetRenderDataFactoryFunc(gridCmp) {\n  // tslint:disable-next-line:only-arrow-functions\n  return function (id) {\n    return parseRenderItemToPixels(gridCmp.getItemRenderData(id));\n  };\n}\n\nfunction ktdGridItemGetRenderDataFactoryFunc(gridCmp) {\n  // Workaround explained: https://github.com/ng-packagr/ng-packagr/issues/696#issuecomment-387114613\n  const resultFunc = __gridItemGetRenderDataFactoryFunc(gridCmp);\n\n  return resultFunc;\n}\n\nlet KtdGridComponent = /*#__PURE__*/(() => {\n  class KtdGridComponent {\n    constructor(gridService, elementRef, renderer, ngZone) {\n      this.gridService = gridService;\n      this.elementRef = elementRef;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      /** Emits when layout change */\n\n      this.layoutUpdated = new EventEmitter();\n      /** Emits when drag starts */\n\n      this.dragStarted = new EventEmitter();\n      /** Emits when resize starts */\n\n      this.resizeStarted = new EventEmitter();\n      /** Emits when drag ends */\n\n      this.dragEnded = new EventEmitter();\n      /** Emits when resize ends */\n\n      this.resizeEnded = new EventEmitter();\n      /**\r\n       * Parent element that contains the scroll. If an string is provided it would search that element by id on the dom.\r\n       * If no data provided or null autoscroll is not performed.\r\n       */\n\n      this.scrollableParent = null;\n      this._compactOnPropsChange = true;\n      this._preventCollision = false;\n      this._scrollSpeed = 2;\n      this._compactType = 'vertical';\n      this._rowHeight = 100;\n      this._cols = 6;\n    }\n    /** Whether or not to update the internal layout when some dependent property change. */\n\n\n    get compactOnPropsChange() {\n      return this._compactOnPropsChange;\n    }\n\n    set compactOnPropsChange(value) {\n      this._compactOnPropsChange = coerceBooleanProperty(value);\n    }\n    /** If true, grid items won't change position when being dragged over. Handy when using no compaction */\n\n\n    get preventCollision() {\n      return this._preventCollision;\n    }\n\n    set preventCollision(value) {\n      this._preventCollision = coerceBooleanProperty(value);\n    }\n    /** Number of CSS pixels that would be scrolled on each 'tick' when auto scroll is performed. */\n\n\n    get scrollSpeed() {\n      return this._scrollSpeed;\n    }\n\n    set scrollSpeed(value) {\n      this._scrollSpeed = coerceNumberProperty(value, 2);\n    }\n    /** Type of compaction that will be applied to the layout (vertical, horizontal or free). Defaults to 'vertical' */\n\n\n    get compactType() {\n      return this._compactType;\n    }\n\n    set compactType(val) {\n      this._compactType = val;\n    }\n    /** Row height in css pixels */\n\n\n    get rowHeight() {\n      return this._rowHeight;\n    }\n\n    set rowHeight(val) {\n      this._rowHeight = Math.max(1, Math.round(coerceNumberProperty(val)));\n    }\n    /** Number of columns  */\n\n\n    get cols() {\n      return this._cols;\n    }\n\n    set cols(val) {\n      this._cols = Math.max(1, Math.round(coerceNumberProperty(val)));\n    }\n    /** Layout of the grid. Array of all the grid items with its 'id' and position on the grid. */\n\n\n    get layout() {\n      return this._layout;\n    }\n\n    set layout(layout) {\n      /**\r\n       * Enhancement:\r\n       * Only set layout if it's reference has changed and use a boolean to track whenever recalculate the layout on ngOnChanges.\r\n       *\r\n       * Why:\r\n       * The normal use of this lib is having the variable layout in the outer component or in a store, assigning it whenever it changes and\r\n       * binded in the component with it's input [layout]. In this scenario, we would always calculate one unnecessary change on the layout when\r\n       * it is re-binded on the input.\r\n       */\n      this._layout = layout;\n    }\n\n    get config() {\n      return {\n        cols: this.cols,\n        rowHeight: this.rowHeight,\n        layout: this.layout,\n        preventCollision: this.preventCollision\n      };\n    }\n\n    ngOnChanges(changes) {\n      let needsCompactLayout = false;\n      let needsRecalculateRenderData = false; // TODO: Does fist change need to be compacted by default?\n      // Compact layout whenever some dependent prop changes.\n\n      if (changes.compactType || changes.cols || changes.layout) {\n        needsCompactLayout = true;\n      } // Check if wee need to recalculate rendering data.\n\n\n      if (needsCompactLayout || changes.rowHeight) {\n        needsRecalculateRenderData = true;\n      } // Only compact layout if lib user has provided it. Lib users that want to save/store always the same layout  as it is represented (compacted)\n      // can use KtdCompactGrid utility and pre-compact the layout. This is the recommended behaviour for always having a the same layout on this component\n      // and the ones that uses it.\n\n\n      if (needsCompactLayout && this.compactOnPropsChange) {\n        this.compactLayout();\n      }\n\n      if (needsRecalculateRenderData) {\n        this.calculateRenderData();\n      }\n    }\n\n    ngAfterContentInit() {\n      this.initSubscriptions();\n    }\n\n    ngAfterContentChecked() {\n      this.render();\n    }\n\n    resize() {\n      this.calculateRenderData();\n      this.render();\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(sub => sub.unsubscribe());\n    }\n\n    compactLayout() {\n      this.layout = compact(this.layout, this.compactType, this.cols);\n    }\n\n    getItemsRenderData() {\n      return Object.assign({}, this._gridItemsRenderData);\n    }\n\n    getItemRenderData(itemId) {\n      return this._gridItemsRenderData[itemId];\n    }\n\n    calculateRenderData() {\n      const clientRect = this.elementRef.nativeElement.getBoundingClientRect();\n      this._gridItemsRenderData = layoutToRenderItems(this.config, clientRect.width, clientRect.height);\n      this._height = getGridHeight(this.layout, this.rowHeight);\n    }\n\n    render() {\n      this.renderer.setStyle(this.elementRef.nativeElement, 'height', `${this._height}px`);\n      this.updateGridItemsStyles();\n    }\n\n    updateGridItemsStyles() {\n      this._gridItems.forEach(item => {\n        const gridItemRenderData = this._gridItemsRenderData[item.id];\n\n        if (gridItemRenderData == null) {\n          console.error(`Couldn\\'t find the specified grid item for the id: ${item.id}`);\n        } else {\n          item.setStyles(parseRenderItemToPixels(gridItemRenderData));\n        }\n      });\n    }\n\n    initSubscriptions() {\n      this.subscriptions = [this._gridItems.changes.pipe(startWith(this._gridItems), switchMap(gridItems => {\n        return merge(...gridItems.map(gridItem => gridItem.dragStart$.pipe(map(event => ({\n          event,\n          gridItem,\n          type: 'drag'\n        })))), ...gridItems.map(gridItem => gridItem.resizeStart$.pipe(map(event => ({\n          event,\n          gridItem,\n          type: 'resize'\n        }))))).pipe(exhaustMap(({\n          event,\n          gridItem,\n          type\n        }) => {\n          // Emit drag or resize start events. Ensure that is start event is inside the zone.\n          this.ngZone.run(() => (type === 'drag' ? this.dragStarted : this.resizeStarted).emit(getDragResizeEventData(gridItem, this.layout))); // Get the correct newStateFunc depending on if we are dragging or resizing\n\n          const calcNewStateFunc = type === 'drag' ? ktdGridItemDragging : ktdGridItemResizing; // Perform drag sequence\n\n          return this.performDragSequence$(gridItem, event, (gridItemId, config, compactionType, draggingData) => calcNewStateFunc(gridItem, config, compactionType, draggingData)).pipe(map(layout => ({\n            layout,\n            gridItem,\n            type\n          })));\n        }));\n      })).subscribe(({\n        layout,\n        gridItem,\n        type\n      }) => {\n        this.layout = layout; // Calculate new rendering data given the new layout.\n\n        this.calculateRenderData(); // Emit drag or resize end events.\n\n        (type === 'drag' ? this.dragEnded : this.resizeEnded).emit(getDragResizeEventData(gridItem, layout)); // Notify that the layout has been updated.\n\n        this.layoutUpdated.emit(layout);\n      })];\n    }\n    /**\r\n     * Perform a general grid drag action, from start to end. A general grid drag action basically includes creating the placeholder element and adding\r\n     * some class animations. calcNewStateFunc needs to be provided in order to calculate the new state of the layout.\r\n     * @param gridItem that is been dragged\r\n     * @param pointerDownEvent event (mousedown or touchdown) where the user initiated the drag\r\n     * @param calcNewStateFunc function that return the new layout state and the drag element position\r\n     */\n\n\n    performDragSequence$(gridItem, pointerDownEvent, calcNewStateFunc) {\n      return new Observable(observer => {\n        // Retrieve grid (parent) and gridItem (draggedElem) client rects.\n        const gridElemClientRect = getMutableClientRect(this.elementRef.nativeElement);\n        const dragElemClientRect = getMutableClientRect(gridItem.elementRef.nativeElement);\n        const scrollableParent = typeof this.scrollableParent === 'string' ? document.getElementById(this.scrollableParent) : this.scrollableParent;\n        this.renderer.addClass(gridItem.elementRef.nativeElement, 'no-transitions');\n        this.renderer.addClass(gridItem.elementRef.nativeElement, 'ktd-grid-item-dragging'); // Create placeholder element. This element would represent the position where the dragged/resized element would be if the action ends\n\n        const placeholderElement = this.renderer.createElement('div');\n        placeholderElement.style.width = `${dragElemClientRect.width}px`;\n        placeholderElement.style.height = `${dragElemClientRect.height}px`;\n        placeholderElement.style.transform = `translateX(${dragElemClientRect.left - gridElemClientRect.left}px) translateY(${dragElemClientRect.top - gridElemClientRect.top}px)`;\n        this.renderer.addClass(placeholderElement, 'ktd-grid-item-placeholder');\n        this.renderer.appendChild(this.elementRef.nativeElement, placeholderElement);\n        let newLayout; // TODO (enhancement): consider move this 'side effect' observable inside the main drag loop.\n        //  - Pros are that we would not repeat subscriptions and takeUntil would shut down observables at the same time.\n        //  - Cons are that moving this functionality as a side effect inside the main drag loop would be confusing.\n\n        const scrollSubscription = this.ngZone.runOutsideAngular(() => (!scrollableParent ? NEVER : this.gridService.mouseOrTouchMove$(document).pipe(map(event => ({\n          pointerX: ktdPointerClientX(event),\n          pointerY: ktdPointerClientY(event)\n        })), ktdScrollIfNearElementClientRect$(scrollableParent, {\n          scrollStep: this.scrollSpeed\n        }))).pipe(takeUntil(ktdMouseOrTouchEnd(document))).subscribe());\n        /**\r\n         * Main subscription, it listens for 'pointer move' and 'scroll' events and recalculates the layout on each emission\r\n         */\n\n        const subscription = this.ngZone.runOutsideAngular(() => merge(combineLatest([this.gridService.mouseOrTouchMove$(document), ...(!scrollableParent ? [of({\n          top: 0,\n          left: 0\n        })] : [ktdGetScrollTotalRelativeDifference$(scrollableParent).pipe(startWith({\n          top: 0,\n          left: 0\n        }) // Force first emission to allow CombineLatest to emit even no scroll event has occurred\n        )])])).pipe(takeUntil(ktdMouseOrTouchEnd(document))).subscribe(([pointerDragEvent, scrollDifference]) => {\n          pointerDragEvent.preventDefault();\n          /**\r\n           * Set the new layout to be the layout in which the calcNewStateFunc would be executed.\r\n           * NOTE: using the mutated layout is the way to go by 'react-grid-layout' utils. If we don't use the previous layout,\r\n           * some utilities from 'react-grid-layout' would not work as expected.\r\n           */\n\n          const currentLayout = newLayout || this.layout;\n          const {\n            layout,\n            draggedItemPos\n          } = calcNewStateFunc(gridItem, {\n            layout: currentLayout,\n            rowHeight: this.rowHeight,\n            cols: this.cols,\n            preventCollision: this.preventCollision\n          }, this.compactType, {\n            pointerDownEvent,\n            pointerDragEvent,\n            gridElemClientRect,\n            dragElemClientRect,\n            scrollDifference\n          });\n          newLayout = layout;\n          this._height = getGridHeight(newLayout, this.rowHeight);\n          this._gridItemsRenderData = layoutToRenderItems({\n            cols: this.cols,\n            rowHeight: this.rowHeight,\n            layout: newLayout,\n            preventCollision: this.preventCollision\n          }, gridElemClientRect.width, gridElemClientRect.height);\n          const placeholderStyles = parseRenderItemToPixels(this._gridItemsRenderData[gridItem.id]); // Put the real final position to the placeholder element\n\n          placeholderElement.style.width = placeholderStyles.width;\n          placeholderElement.style.height = placeholderStyles.height;\n          placeholderElement.style.transform = `translateX(${placeholderStyles.left}) translateY(${placeholderStyles.top})`; // modify the position of the dragged item to be the once we want (for example the mouse position or whatever)\n\n          this._gridItemsRenderData[gridItem.id] = Object.assign(Object.assign({}, draggedItemPos), {\n            id: this._gridItemsRenderData[gridItem.id].id\n          });\n          this.render();\n        }, error => observer.error(error), () => {\n          this.ngZone.run(() => {\n            // Remove drag classes\n            this.renderer.removeClass(gridItem.elementRef.nativeElement, 'no-transitions');\n            this.renderer.removeClass(gridItem.elementRef.nativeElement, 'ktd-grid-item-dragging'); // Remove placeholder element from the dom\n            // NOTE: If we don't put the removeChild inside the zone it would not work... This may be a bug from angular or maybe is the intended behaviour, although strange.\n            // It should work since AFAIK this action should not be done in a CD cycle.\n\n            this.renderer.removeChild(this.elementRef.nativeElement, placeholderElement);\n\n            if (newLayout) {\n              // TODO: newLayout should already be pruned. If not, it should have type Layout, not KtdGridLayout as it is now.\n              // Prune react-grid-layout compact extra properties.\n              observer.next(newLayout.map(item => ({\n                id: item.id,\n                x: item.x,\n                y: item.y,\n                w: item.w,\n                h: item.h,\n                minW: item.minW,\n                minH: item.minH,\n                maxW: item.maxW,\n                maxH: item.maxH\n              })));\n            } else {\n              // TODO: Need we really to emit if there is no layout change but drag started and ended?\n              observer.next(this.layout);\n            }\n\n            observer.complete();\n          });\n        }));\n        return () => {\n          scrollSubscription.unsubscribe();\n          subscription.unsubscribe();\n        };\n      });\n    }\n\n  }\n\n  KtdGridComponent.ɵfac = function KtdGridComponent_Factory(t) {\n    return new (t || KtdGridComponent)(i0.ɵɵdirectiveInject(KtdGridService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  KtdGridComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: KtdGridComponent,\n    selectors: [[\"ktd-grid\"]],\n    contentQueries: function KtdGridComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, KtdGridItemComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._gridItems = _t);\n      }\n    },\n    inputs: {\n      scrollableParent: \"scrollableParent\",\n      compactOnPropsChange: \"compactOnPropsChange\",\n      preventCollision: \"preventCollision\",\n      scrollSpeed: \"scrollSpeed\",\n      compactType: \"compactType\",\n      rowHeight: \"rowHeight\",\n      cols: \"cols\",\n      layout: \"layout\"\n    },\n    outputs: {\n      layoutUpdated: \"layoutUpdated\",\n      dragStarted: \"dragStarted\",\n      resizeStarted: \"resizeStarted\",\n      dragEnded: \"dragEnded\",\n      resizeEnded: \"resizeEnded\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: GRID_ITEM_GET_RENDER_DATA_TOKEN,\n      useFactory: ktdGridItemGetRenderDataFactoryFunc,\n      deps: [KtdGridComponent]\n    }]), i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function KtdGridComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"ktd-grid{display:block;position:relative;width:100%}ktd-grid ktd-grid-item.ktd-grid-item-dragging{z-index:1000}ktd-grid ktd-grid-item.no-transitions{transition:none!important}ktd-grid .ktd-grid-item-placeholder{position:absolute;background-color:#8b0000;opacity:.6;z-index:0;transition-property:transform;transition:all .15s ease}\\n\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return KtdGridComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet KtdGridModule = /*#__PURE__*/(() => {\n  class KtdGridModule {}\n\n  KtdGridModule.ɵfac = function KtdGridModule_Factory(t) {\n    return new (t || KtdGridModule)();\n  };\n\n  KtdGridModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: KtdGridModule\n  });\n  KtdGridModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [KtdGridService],\n    imports: [[CommonModule]]\n  });\n  return KtdGridModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\r\n * Public API Surface of grid\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { GRID_ITEM_GET_RENDER_DATA_TOKEN, KTD_GRID_DRAG_HANDLE, KTD_GRID_RESIZE_HANDLE, KtdGridComponent, KtdGridDragHandle, KtdGridItemComponent, KtdGridModule, KtdGridResizeHandle, __gridItemGetRenderDataFactoryFunc, ktdGridCompact, ktdGridItemGetRenderDataFactoryFunc, ktdTrackById, parseRenderItemToPixels }; //# sourceMappingURL=katoid-angular-grid-layout.js.map","map":null,"metadata":{},"sourceType":"module"}