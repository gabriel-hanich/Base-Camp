{"ast":null,"code":"import { iif, fromEvent, merge, Observable, Subject, BehaviorSubject, NEVER, interval, animationFrameScheduler, combineLatest, of } from 'rxjs';\nimport { filter, switchMap, startWith, exhaustMap, takeUntil, take, map, tap, distinctUntilChanged } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Directive, Injectable, ElementRef, Component, ChangeDetectionStrategy, Inject, ContentChildren, ViewChild, Input, EventEmitter, ViewEncapsulation, Output, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n/**\r\n * IMPORTANT:\r\n * This utils are taken from the project: https://github.com/STRML/react-grid-layout.\r\n * The code should be as less modified as possible for easy maintenance.\r\n */\n\nconst _c0 = [\"resizeElem\"];\nconst _c1 = [\"*\"];\nconst DEBUG = false;\n/**\r\n * Return the bottom coordinate of the layout.\r\n *\r\n * @param  {Array} layout Layout array.\r\n * @return {Number}       Bottom coordinate.\r\n */\n\nfunction bottom(layout) {\n  let max = 0,\n      bottomY;\n\n  for (let i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n\n    if (bottomY > max) {\n      max = bottomY;\n    }\n  }\n\n  return max;\n}\n\nfunction cloneLayout(layout) {\n  const newLayout = Array(layout.length);\n\n  for (let i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n\n  return newLayout;\n} // Fast path to cloning, since this is monomorphic\n\n/** NOTE: This code has been modified from the original source */\n\n\nfunction cloneLayoutItem(layoutItem) {\n  const clonedLayoutItem = {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    id: layoutItem.id,\n    moved: !!layoutItem.moved,\n    static: !!layoutItem.static\n  };\n\n  if (layoutItem.minW !== undefined) {\n    clonedLayoutItem.minW = layoutItem.minW;\n  }\n\n  if (layoutItem.maxW !== undefined) {\n    clonedLayoutItem.maxW = layoutItem.maxW;\n  }\n\n  if (layoutItem.minH !== undefined) {\n    clonedLayoutItem.minH = layoutItem.minH;\n  }\n\n  if (layoutItem.maxH !== undefined) {\n    clonedLayoutItem.maxH = layoutItem.maxH;\n  } // These can be null\n\n\n  if (layoutItem.isDraggable !== undefined) {\n    clonedLayoutItem.isDraggable = layoutItem.isDraggable;\n  }\n\n  if (layoutItem.isResizable !== undefined) {\n    clonedLayoutItem.isResizable = layoutItem.isResizable;\n  }\n\n  return clonedLayoutItem;\n}\n/**\r\n * Given two layoutitems, check if they collide.\r\n */\n\n\nfunction collides(l1, l2) {\n  if (l1.id === l2.id) {\n    return false;\n  } // same element\n\n\n  if (l1.x + l1.w <= l2.x) {\n    return false;\n  } // l1 is left of l2\n\n\n  if (l1.x >= l2.x + l2.w) {\n    return false;\n  } // l1 is right of l2\n\n\n  if (l1.y + l1.h <= l2.y) {\n    return false;\n  } // l1 is above l2\n\n\n  if (l1.y >= l2.y + l2.h) {\n    return false;\n  } // l1 is below l2\n\n\n  return true; // boxes overlap\n}\n/**\r\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\r\n * between items.\r\n *\r\n * @param  {Array} layout Layout.\r\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\r\n *   vertically.\r\n * @return {Array}       Compacted Layout.\r\n */\n\n\nfunction compact(layout, compactType, cols) {\n  // Statics go in the compareWith array right away so items flow around them.\n  const compareWith = getStatics(layout); // We go through the items by row and column.\n\n  const sorted = sortLayoutItems(layout, compactType); // Holding for new items.\n\n  const out = Array(layout.length);\n\n  for (let i = 0, len = sorted.length; i < len; i++) {\n    let l = cloneLayoutItem(sorted[i]); // Don't move static elements\n\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted); // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n\n      compareWith.push(l);\n    } // Add to output array to make sure they still come out in the right order.\n\n\n    out[layout.indexOf(sorted[i])] = l; // Clear moved flag, if it exists.\n\n    l.moved = false;\n  }\n\n  return out;\n}\n\nconst heightWidth = {\n  x: 'w',\n  y: 'h'\n};\n/**\r\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\r\n */\n\nfunction resolveCompactionCollision(layout, item, moveToCoord, axis) {\n  const sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  const itemIndex = layout.map(layoutItem => {\n    return layoutItem.id;\n  }).indexOf(item.id); // Go through each item we collide with.\n\n  for (let i = itemIndex + 1; i < layout.length; i++) {\n    const otherItem = layout[i]; // Ignore static items\n\n    if (otherItem.static) {\n      continue;\n    } // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n\n\n    if (otherItem.y > item.y + item.h) {\n      break;\n    }\n\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n\n  item[axis] = moveToCoord;\n}\n/**\r\n * Compact an item in the layout.\r\n */\n\n\nfunction compactItem(compareWith, l, compactType, cols, fullLayout) {\n  const compactV = compactType === 'vertical';\n  const compactH = compactType === 'horizontal';\n\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y); // Move the element up as far as it can go without colliding.\n\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    l.y = Math.min(bottom(compareWith), l.y); // Move the element left as far as it can go without colliding.\n\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  } // Move it down, and keep moving it down if it's colliding.\n\n\n  let collides;\n\n  while (collides = getFirstCollision(compareWith, l)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, 'x');\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, 'y');\n    } // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n\n\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n    }\n  }\n\n  return l;\n}\n/**\r\n * Given a layout, make sure all elements fit within its bounds.\r\n *\r\n * @param  {Array} layout Layout array.\r\n * @param  {Number} bounds Number of columns.\r\n */\n\n\nfunction correctBounds(layout, bounds) {\n  const collidesWith = getStatics(layout);\n\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const l = layout[i]; // Overflows right\n\n    if (l.x + l.w > bounds.cols) {\n      l.x = bounds.cols - l.w;\n    } // Overflows left\n\n\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n\n    if (!l.static) {\n      collidesWith.push(l);\n    } else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n\n  return layout;\n}\n/**\r\n * Get a layout item by ID. Used so we can override later on if necessary.\r\n *\r\n * @param  {Array}  layout Layout array.\r\n * @param  {String} id     ID\r\n * @return {LayoutItem}    Item at ID.\r\n */\n\n\nfunction getLayoutItem(layout, id) {\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].id === id) {\n      return layout[i];\n    }\n  }\n\n  return null;\n}\n/**\r\n * Returns the first item this layout collides with.\r\n * It doesn't appear to matter which order we approach this from, although\r\n * perhaps that is the wrong thing to do.\r\n *\r\n * @param  {Object} layoutItem Layout item.\r\n * @return {Object|undefined}  A colliding layout item, or undefined.\r\n */\n\n\nfunction getFirstCollision(layout, layoutItem) {\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) {\n      return layout[i];\n    }\n  }\n\n  return null;\n}\n\nfunction getAllCollisions(layout, layoutItem) {\n  return layout.filter(l => collides(l, layoutItem));\n}\n/**\r\n * Get all static elements.\r\n * @param  {Array} layout Array of layout objects.\r\n * @return {Array}        Array of static layout items..\r\n */\n\n\nfunction getStatics(layout) {\n  return layout.filter(l => l.static);\n}\n/**\r\n * Move an element. Responsible for doing cascading movements of other elements.\r\n *\r\n * @param  {Array}      layout            Full layout to modify.\r\n * @param  {LayoutItem} l                 element to move.\r\n * @param  {Number}     [x]               X position in grid units.\r\n * @param  {Number}     [y]               Y position in grid units.\r\n */\n\n\nfunction moveElement(layout, l, x, y, isUserAction, preventCollision, compactType, cols) {\n  // If this is static and not explicitly enabled as draggable,\n  // no move is possible, so we can short-circuit this immediately.\n  if (l.static && l.isDraggable !== true) {\n    return layout;\n  } // Short-circuit if nothing to do.\n\n\n  if (l.y === y && l.x === x) {\n    return layout;\n  }\n\n  log(`Moving element ${l.id} to [${String(x)},${String(y)}] from [${l.x},${l.y}]`);\n  const oldX = l.x;\n  const oldY = l.y; // This is quite a bit faster than extending the object\n\n  if (typeof x === 'number') {\n    l.x = x;\n  }\n\n  if (typeof y === 'number') {\n    l.y = y;\n  }\n\n  l.moved = true; // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n\n  let sorted = sortLayoutItems(layout, compactType);\n  const movingUp = compactType === 'vertical' && typeof y === 'number' ? oldY >= y : compactType === 'horizontal' && typeof x === 'number' ? oldX >= x : false;\n\n  if (movingUp) {\n    sorted = sorted.reverse();\n  }\n\n  const collisions = getAllCollisions(sorted, l); // There was a collision; abort\n\n  if (preventCollision && collisions.length) {\n    log(`Collision prevented on ${l.id}, reverting.`);\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout;\n  } // Move each item that collides away from this element.\n\n\n  for (let i = 0, len = collisions.length; i < len; i++) {\n    const collision = collisions[i];\n    log(`Resolving collision between ${l.id} at [${l.x},${l.y}] and ${collision.id} at [${collision.x},${collision.y}]`); // Short circuit so we can't infinite loop\n\n    if (collision.moved) {\n      continue;\n    } // Don't move static items - we have to move *this* element away\n\n\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n\n  return layout;\n}\n/**\r\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\r\n * We attempt to move it up if there's room, otherwise it goes below.\r\n *\r\n * @param  {Array} layout            Full layout to modify.\r\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\r\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\r\n */\n\n\nfunction moveElementAwayFromCollision(layout, collidesWith, itemToMove, isUserAction, compactType, cols) {\n  const compactH = compactType === 'horizontal'; // Compact vertically if not set to horizontal\n\n  const compactV = compactType !== 'horizontal';\n  const preventCollision = collidesWith.static; // we're already colliding (not for static items)\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false; // Make a mock item so we don't modify the item here, only modify in moveElement.\n\n    const fakeItem = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      id: '-1'\n    }; // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n\n    if (!getFirstCollision(layout, fakeItem)) {\n      log(`Doing reverse collision on ${itemToMove.id} up to [${fakeItem.x},${fakeItem.y}].`);\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n/**\r\n * Helper to convert a number to a percentage string.\r\n *\r\n * @param  {Number} num Any number\r\n * @return {String}     That number as a percentage.\r\n */\n\n\nfunction perc(num) {\n  return num * 100 + '%';\n}\n\nfunction setTransform({\n  top,\n  left,\n  width,\n  height\n}) {\n  // Replace unitless items with px\n  const translate = `translate(${left}px,${top}px)`;\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: 'absolute'\n  };\n}\n\nfunction setTopLeft({\n  top,\n  left,\n  width,\n  height\n}) {\n  return {\n    top: `${top}px`,\n    left: `${left}px`,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: 'absolute'\n  };\n}\n/**\r\n * Get layout items sorted from top left to right and down.\r\n *\r\n * @return {Array} Array of layout objects.\r\n * @return {Array}        Layout, sorted static items first.\r\n */\n\n\nfunction sortLayoutItems(layout, compactType) {\n  if (compactType === 'horizontal') {\n    return sortLayoutItemsByColRow(layout);\n  } else {\n    return sortLayoutItemsByRowCol(layout);\n  }\n}\n\nfunction sortLayoutItemsByRowCol(layout) {\n  return [].concat(layout).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n\n    return -1;\n  });\n}\n\nfunction sortLayoutItemsByColRow(layout) {\n  return [].concat(layout).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n\n    return -1;\n  });\n}\n/**\r\n * Validate a layout. Throws errors.\r\n *\r\n * @param  {Array}  layout        Array of layout items.\r\n * @param  {String} [contextName] Context name for errors.\r\n * @throw  {Error}                Validation error.\r\n */\n\n\nfunction validateLayout(layout, contextName = 'Layout') {\n  const subProps = ['x', 'y', 'w', 'h'];\n\n  if (!Array.isArray(layout)) {\n    throw new Error(contextName + ' must be an array!');\n  }\n\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const item = layout[i];\n\n    for (let j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== 'number') {\n        throw new Error('ReactGridLayout: ' + contextName + '[' + i + '].' + subProps[j] + ' must be a number!');\n      }\n    }\n\n    if (item.id && typeof item.id !== 'string') {\n      throw new Error('ReactGridLayout: ' + contextName + '[' + i + '].i must be a string!');\n    }\n\n    if (item.static !== undefined && typeof item.static !== 'boolean') {\n      throw new Error('ReactGridLayout: ' + contextName + '[' + i + '].static must be a boolean!');\n    }\n  }\n} // Flow can't really figure this out, so we just use Object\n\n\nfunction autoBindHandlers(el, fns) {\n  fns.forEach(key => el[key] = el[key].bind(el));\n}\n\nfunction log(...args) {\n  if (!DEBUG) {\n    return;\n  } // eslint-disable-next-line no-console\n\n\n  console.log(...args);\n}\n\nconst noop = () => {};\n/** Cached result of whether the user's browser supports passive event listeners. */\n\n\nlet supportsPassiveEvents;\n/**\r\n * Checks whether the user's browser supports passive event listeners.\r\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\r\n */\n\nfunction ktdSupportsPassiveEventListeners() {\n  if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n    try {\n      window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\n        get: () => supportsPassiveEvents = true\n      }));\n    } finally {\n      supportsPassiveEvents = supportsPassiveEvents || false;\n    }\n  }\n\n  return supportsPassiveEvents;\n}\n/**\r\n * Normalizes an `AddEventListener` object to something that can be passed\r\n * to `addEventListener` on any browser, no matter whether it supports the\r\n * `options` parameter.\r\n * @param options Object to be normalized.\r\n */\n\n\nfunction ktdNormalizePassiveListenerOptions(options) {\n  return ktdSupportsPassiveEventListeners() ? options : !!options.capture;\n}\n/** Options that can be used to bind a passive event listener. */\n\n\nconst passiveEventListenerOptions = ktdNormalizePassiveListenerOptions({\n  passive: true\n});\n/** Options that can be used to bind an active event listener. */\n\nconst activeEventListenerOptions = ktdNormalizePassiveListenerOptions({\n  passive: false\n});\nlet isMobile = null;\n\nfunction ktdIsMobileOrTablet() {\n  if (isMobile != null) {\n    return isMobile;\n  } // Generic match pattern to identify mobile or tablet devices\n\n\n  const isMobileDevice = /Android|webOS|BlackBerry|Windows Phone|iPad|iPhone|iPod/i.test(navigator.userAgent); // Since IOS 13 is not safe to just check for the generic solution. See: https://stackoverflow.com/questions/58019463/how-to-detect-device-name-in-safari-on-ios-13-while-it-doesnt-show-the-correct\n\n  const isIOSMobileDevice = /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1;\n  isMobile = isMobileDevice || isIOSMobileDevice;\n  return isMobile;\n}\n\nfunction ktdIsMouseEvent(event) {\n  return event.clientX != null;\n}\n\nfunction ktdIsTouchEvent(event) {\n  return event.touches != null && event.touches.length != null;\n}\n\nfunction ktdPointerClientX(event) {\n  return ktdIsMouseEvent(event) ? event.clientX : event.touches[0].clientX;\n}\n\nfunction ktdPointerClientY(event) {\n  return ktdIsMouseEvent(event) ? event.clientY : event.touches[0].clientY;\n}\n\nfunction ktdPointerClient(event) {\n  return {\n    clientX: ktdIsMouseEvent(event) ? event.clientX : event.touches[0].clientX,\n    clientY: ktdIsMouseEvent(event) ? event.clientY : event.touches[0].clientY\n  };\n}\n/**\r\n * Emits when a mousedown or touchstart emits. Avoids conflicts between both events.\r\n * @param element, html element where to  listen the events.\r\n * @param touchNumber number of the touch to track the event, default to the first one.\r\n */\n\n\nfunction ktdMouseOrTouchDown(element, touchNumber = 1) {\n  return iif(() => ktdIsMobileOrTablet(), fromEvent(element, 'touchstart', passiveEventListenerOptions).pipe(filter(touchEvent => touchEvent.touches.length === touchNumber)), fromEvent(element, 'mousedown', activeEventListenerOptions).pipe(filter(mouseEvent => {\n    /**\r\n     * 0 : Left mouse button\r\n     * 1 : Wheel button or middle button (if present)\r\n     * 2 : Right mouse button\r\n     */\n    return mouseEvent.button === 0; // Mouse down to be only fired if is left click\n  })));\n}\n/**\r\n * Emits when a 'mousemove' or a 'touchmove' event gets fired.\r\n * @param element, html element where to  listen the events.\r\n * @param touchNumber number of the touch to track the event, default to the first one.\r\n */\n\n\nfunction ktdMouseOrTouchMove(element, touchNumber = 1) {\n  return iif(() => ktdIsMobileOrTablet(), fromEvent(element, 'touchmove', activeEventListenerOptions).pipe(filter(touchEvent => touchEvent.touches.length === touchNumber)), fromEvent(element, 'mousemove', activeEventListenerOptions));\n}\n\nfunction ktdTouchEnd(element, touchNumber = 1) {\n  return merge(fromEvent(element, 'touchend').pipe(filter(touchEvent => touchEvent.touches.length === touchNumber - 1)), fromEvent(element, 'touchcancel').pipe(filter(touchEvent => touchEvent.touches.length === touchNumber - 1)));\n}\n/**\r\n * Emits when a there is a 'mouseup' or the touch ends.\r\n * @param element, html element where to  listen the events.\r\n * @param touchNumber number of the touch to track the event, default to the first one.\r\n */\n\n\nfunction ktdMouseOrTouchEnd(element, touchNumber = 1) {\n  return iif(() => ktdIsMobileOrTablet(), ktdTouchEnd(element, touchNumber), fromEvent(element, 'mouseup'));\n}\n/** Tracks items by id. This function is mean to be used in conjunction with the ngFor that renders the 'ktd-grid-items' */\n\n\nfunction ktdTrackById(index, item) {\n  return item.id;\n}\n/**\r\n * Call react-grid-layout utils 'compact()' function and return the compacted layout.\r\n * @param layout to be compacted.\r\n * @param compactType, type of compaction.\r\n * @param cols, number of columns of the grid.\r\n */\n\n\nfunction ktdGridCompact(layout, compactType, cols) {\n  return compact(layout, compactType, cols) // Prune react-grid-layout compact extra properties.\n  .map(item => ({\n    id: item.id,\n    x: item.x,\n    y: item.y,\n    w: item.w,\n    h: item.h,\n    minW: item.minW,\n    minH: item.minH,\n    maxW: item.maxW,\n    maxH: item.maxH\n  }));\n}\n\nfunction screenXPosToGridValue(screenXPos, cols, width) {\n  return Math.round(screenXPos * cols / width);\n}\n\nfunction screenYPosToGridValue(screenYPos, rowHeight, height) {\n  return Math.round(screenYPos / rowHeight);\n}\n/** Returns a Dictionary where the key is the id and the value is the change applied to that item. If no changes Dictionary is empty. */\n\n\nfunction ktdGetGridLayoutDiff(gridLayoutA, gridLayoutB) {\n  const diff = {};\n  gridLayoutA.forEach(itemA => {\n    const itemB = gridLayoutB.find(_itemB => _itemB.id === itemA.id);\n\n    if (itemB != null) {\n      const posChanged = itemA.x !== itemB.x || itemA.y !== itemB.y;\n      const sizeChanged = itemA.w !== itemB.w || itemA.h !== itemB.h;\n      const change = posChanged && sizeChanged ? 'moveresize' : posChanged ? 'move' : sizeChanged ? 'resize' : null;\n\n      if (change) {\n        diff[itemB.id] = {\n          change\n        };\n      }\n    }\n  });\n  return diff;\n}\n/**\r\n * Given the grid config & layout data and the current drag position & information, returns the corresponding layout and drag item position\r\n * @param gridItem grid item that is been dragged\r\n * @param config current grid configuration\r\n * @param compactionType type of compaction that will be performed\r\n * @param draggingData contains all the information about the drag\r\n */\n\n\nfunction ktdGridItemDragging(gridItem, config, compactionType, draggingData) {\n  const {\n    pointerDownEvent,\n    pointerDragEvent,\n    gridElemClientRect,\n    dragElemClientRect,\n    scrollDifference\n  } = draggingData;\n  const gridItemId = gridItem.id;\n  const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId);\n  const clientStartX = ktdPointerClientX(pointerDownEvent);\n  const clientStartY = ktdPointerClientY(pointerDownEvent);\n  const clientX = ktdPointerClientX(pointerDragEvent);\n  const clientY = ktdPointerClientY(pointerDragEvent);\n  const offsetX = clientStartX - dragElemClientRect.left;\n  const offsetY = clientStartY - dragElemClientRect.top; // Grid element positions taking into account the possible scroll total difference from the beginning.\n\n  const gridElementLeftPosition = gridElemClientRect.left + scrollDifference.left;\n  const gridElementTopPosition = gridElemClientRect.top + scrollDifference.top; // Calculate position relative to the grid element.\n\n  const gridRelXPos = clientX - gridElementLeftPosition - offsetX;\n  const gridRelYPos = clientY - gridElementTopPosition - offsetY; // Get layout item position\n\n  const layoutItem = Object.assign(Object.assign({}, draggingElemPrevItem), {\n    x: screenXPosToGridValue(gridRelXPos, config.cols, gridElemClientRect.width),\n    y: screenYPosToGridValue(gridRelYPos, config.rowHeight, gridElemClientRect.height)\n  }); // Correct the values if they overflow, since 'moveElement' function doesn't do it\n\n  layoutItem.x = Math.max(0, layoutItem.x);\n  layoutItem.y = Math.max(0, layoutItem.y);\n\n  if (layoutItem.x + layoutItem.w > config.cols) {\n    layoutItem.x = Math.max(0, config.cols - layoutItem.w);\n  } // Parse to LayoutItem array data in order to use 'react.grid-layout' utils\n\n\n  const layoutItems = config.layout;\n  const draggedLayoutItem = layoutItems.find(item => item.id === gridItemId);\n  let newLayoutItems = moveElement(layoutItems, draggedLayoutItem, layoutItem.x, layoutItem.y, true, config.preventCollision, compactionType, config.cols);\n  newLayoutItems = compact(newLayoutItems, compactionType, config.cols);\n  return {\n    layout: newLayoutItems,\n    draggedItemPos: {\n      top: gridRelYPos,\n      left: gridRelXPos,\n      width: dragElemClientRect.width,\n      height: dragElemClientRect.height\n    }\n  };\n}\n/**\r\n * Given the grid config & layout data and the current drag position & information, returns the corresponding layout and drag item position\r\n * @param gridItem grid item that is been dragged\r\n * @param config current grid configuration\r\n * @param compactionType type of compaction that will be performed\r\n * @param draggingData contains all the information about the drag\r\n */\n\n\nfunction ktdGridItemResizing(gridItem, config, compactionType, draggingData) {\n  var _a, _b, _c, _d;\n\n  const {\n    pointerDownEvent,\n    pointerDragEvent,\n    gridElemClientRect,\n    dragElemClientRect,\n    scrollDifference\n  } = draggingData;\n  const gridItemId = gridItem.id;\n  const clientStartX = ktdPointerClientX(pointerDownEvent);\n  const clientStartY = ktdPointerClientY(pointerDownEvent);\n  const clientX = ktdPointerClientX(pointerDragEvent);\n  const clientY = ktdPointerClientY(pointerDragEvent); // Get the difference between the mouseDown and the position 'right' of the resize element.\n\n  const resizeElemOffsetX = dragElemClientRect.width - (clientStartX - dragElemClientRect.left);\n  const resizeElemOffsetY = dragElemClientRect.height - (clientStartY - dragElemClientRect.top);\n  const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId);\n  const width = clientX + resizeElemOffsetX - (dragElemClientRect.left + scrollDifference.left);\n  const height = clientY + resizeElemOffsetY - (dragElemClientRect.top + scrollDifference.top); // Get layout item grid position\n\n  const layoutItem = Object.assign(Object.assign({}, draggingElemPrevItem), {\n    w: screenXPosToGridValue(width, config.cols, gridElemClientRect.width),\n    h: screenYPosToGridValue(height, config.rowHeight, gridElemClientRect.height)\n  });\n  layoutItem.w = limitNumberWithinRange(layoutItem.w, (_a = gridItem.minW) !== null && _a !== void 0 ? _a : layoutItem.minW, (_b = gridItem.maxW) !== null && _b !== void 0 ? _b : layoutItem.maxW);\n  layoutItem.h = limitNumberWithinRange(layoutItem.h, (_c = gridItem.minH) !== null && _c !== void 0 ? _c : layoutItem.minH, (_d = gridItem.maxH) !== null && _d !== void 0 ? _d : layoutItem.maxH);\n\n  if (layoutItem.x + layoutItem.w > config.cols) {\n    layoutItem.w = Math.max(1, config.cols - layoutItem.x);\n  }\n\n  if (config.preventCollision) {\n    const maxW = layoutItem.w;\n    const maxH = layoutItem.h;\n    let colliding = hasCollision(config.layout, layoutItem);\n    let shrunkDimension;\n\n    while (colliding) {\n      shrunkDimension = getDimensionToShrink(layoutItem, shrunkDimension);\n      layoutItem[shrunkDimension]--;\n      colliding = hasCollision(config.layout, layoutItem);\n    }\n\n    if (shrunkDimension === 'w') {\n      layoutItem.h = maxH;\n      colliding = hasCollision(config.layout, layoutItem);\n\n      while (colliding) {\n        layoutItem.h--;\n        colliding = hasCollision(config.layout, layoutItem);\n      }\n    }\n\n    if (shrunkDimension === 'h') {\n      layoutItem.w = maxW;\n      colliding = hasCollision(config.layout, layoutItem);\n\n      while (colliding) {\n        layoutItem.w--;\n        colliding = hasCollision(config.layout, layoutItem);\n      }\n    }\n  }\n\n  const newLayoutItems = config.layout.map(item => {\n    return item.id === gridItemId ? layoutItem : item;\n  });\n  return {\n    layout: compact(newLayoutItems, compactionType, config.cols),\n    draggedItemPos: {\n      top: dragElemClientRect.top - gridElemClientRect.top,\n      left: dragElemClientRect.left - gridElemClientRect.left,\n      width,\n      height\n    }\n  };\n}\n\nfunction hasCollision(layout, layoutItem) {\n  return !!getFirstCollision(layout, layoutItem);\n}\n\nfunction getDimensionToShrink(layoutItem, lastShrunk) {\n  if (layoutItem.h <= 1) {\n    return 'w';\n  }\n\n  if (layoutItem.w <= 1) {\n    return 'h';\n  }\n\n  return lastShrunk === 'w' ? 'h' : 'w';\n}\n/**\r\n * Given the current number and min/max values, returns the number within the range\r\n * @param number can be any numeric value\r\n * @param min minimum value of range\r\n * @param max maximum value of range\r\n */\n\n\nfunction limitNumberWithinRange(num, min = 1, max = Infinity) {\n  return Math.min(Math.max(num, min < 1 ? 1 : min), max);\n}\n/**\r\n * Injection token that can be used to reference instances of `KtdGridDragHandle`. It serves as\r\n * alternative token to the actual `KtdGridDragHandle` class which could cause unnecessary\r\n * retention of the class and its directive metadata.\r\n */\n\n\nconst KTD_GRID_DRAG_HANDLE = new InjectionToken('KtdGridDragHandle');\n/** Handle that can be used to drag a KtdGridItem instance. */\n// tslint:disable-next-line:directive-class-suffix\n\nclass KtdGridDragHandle {\n  constructor(element) {\n    this.element = element;\n  }\n\n}\n\nKtdGridDragHandle.ɵfac = function KtdGridDragHandle_Factory(t) {\n  return new (t || KtdGridDragHandle)(i0.ɵɵdirectiveInject(i0.ElementRef));\n};\n\nKtdGridDragHandle.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: KtdGridDragHandle,\n  selectors: [[\"\", \"ktdGridDragHandle\", \"\"]],\n  hostAttrs: [1, \"ktd-grid-drag-handle\"],\n  features: [i0.ɵɵProvidersFeature([{\n    provide: KTD_GRID_DRAG_HANDLE,\n    useExisting: KtdGridDragHandle\n  }])]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(KtdGridDragHandle, [{\n    type: Directive,\n    args: [{\n      selector: '[ktdGridDragHandle]',\n      host: {\n        class: 'ktd-grid-drag-handle'\n      },\n      providers: [{\n        provide: KTD_GRID_DRAG_HANDLE,\n        useExisting: KtdGridDragHandle\n      }]\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }];\n  }, null);\n})();\n/**\r\n * Injection token that can be used to reference instances of `KtdGridResizeHandle`. It serves as\r\n * alternative token to the actual `KtdGridResizeHandle` class which could cause unnecessary\r\n * retention of the class and its directive metadata.\r\n */\n\n\nconst KTD_GRID_RESIZE_HANDLE = new InjectionToken('KtdGridResizeHandle');\n/** Handle that can be used to drag a KtdGridItem instance. */\n\nclass KtdGridResizeHandle {\n  constructor(element) {\n    this.element = element;\n  }\n\n}\n\nKtdGridResizeHandle.ɵfac = function KtdGridResizeHandle_Factory(t) {\n  return new (t || KtdGridResizeHandle)(i0.ɵɵdirectiveInject(i0.ElementRef));\n};\n\nKtdGridResizeHandle.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: KtdGridResizeHandle,\n  selectors: [[\"\", \"ktdGridResizeHandle\", \"\"]],\n  hostAttrs: [1, \"ktd-grid-resize-handle\"],\n  features: [i0.ɵɵProvidersFeature([{\n    provide: KTD_GRID_RESIZE_HANDLE,\n    useExisting: KtdGridResizeHandle\n  }])]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(KtdGridResizeHandle, [{\n    type: Directive,\n    args: [{\n      selector: '[ktdGridResizeHandle]',\n      host: {\n        class: 'ktd-grid-resize-handle'\n      },\n      providers: [{\n        provide: KTD_GRID_RESIZE_HANDLE,\n        useExisting: KtdGridResizeHandle\n      }]\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }];\n  }, null);\n})();\n\nconst GRID_ITEM_GET_RENDER_DATA_TOKEN = new InjectionToken('GRID_ITEM_GET_RENDER_DATA_TOKEN');\n/** Runs source observable outside the zone */\n\nfunction ktdOutsideZone(zone) {\n  return source => {\n    return new Observable(observer => {\n      return zone.runOutsideAngular(() => source.subscribe(observer));\n    });\n  };\n}\n/** Rxjs operator that makes source observable to no emit any data */\n\n\nfunction ktdNoEmit() {\n  return source$ => {\n    return source$.pipe(filter(() => false));\n  };\n}\n/** Coerces a data-bound value (typically a string) to a boolean. */\n\n\nfunction coerceBooleanProperty(value) {\n  return value != null && `${value}` !== 'false';\n}\n\nfunction coerceNumberProperty(value, fallbackValue = 0) {\n  return _isNumberValue(value) ? Number(value) : fallbackValue;\n}\n/**\r\n * Whether the provided value is considered a number.\r\n * @docs-private\r\n */\n\n\nfunction _isNumberValue(value) {\n  // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n  // and other non-number values as NaN, where Number just uses 0) but it considers the string\n  // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n  return !isNaN(parseFloat(value)) && !isNaN(Number(value));\n}\n/** Event options that can be used to bind an active, capturing event. */\n\n\nconst activeCapturingEventOptions = ktdNormalizePassiveListenerOptions({\n  passive: false,\n  capture: true\n});\n\nclass KtdGridService {\n  constructor(ngZone) {\n    this.ngZone = ngZone;\n    this.touchMoveSubject = new Subject();\n    this.touchMove$ = this.touchMoveSubject.asObservable();\n    this.registerTouchMoveSubscription();\n  }\n\n  ngOnDestroy() {\n    this.touchMoveSubscription.unsubscribe();\n  }\n\n  mouseOrTouchMove$(element) {\n    return iif(() => ktdIsMobileOrTablet(), this.touchMove$, fromEvent(element, 'mousemove', activeCapturingEventOptions) // TODO: Fix rxjs typings, boolean should be a good param too.\n    );\n  }\n\n  registerTouchMoveSubscription() {\n    // The `touchmove` event gets bound once, ahead of time, because WebKit\n    // won't preventDefault on a dynamically-added `touchmove` listener.\n    // See https://bugs.webkit.org/show_bug.cgi?id=184250.\n    this.touchMoveSubscription = this.ngZone.runOutsideAngular(() => // The event handler has to be explicitly active,\n    // because newer browsers make it passive by default.\n    fromEvent(document, 'touchmove', activeCapturingEventOptions) // TODO: Fix rxjs typings, boolean should be a good param too.\n    .pipe(filter(touchEvent => touchEvent.touches.length === 1)).subscribe(touchEvent => this.touchMoveSubject.next(touchEvent)));\n  }\n\n}\n\nKtdGridService.ɵfac = function KtdGridService_Factory(t) {\n  return new (t || KtdGridService)(i0.ɵɵinject(i0.NgZone));\n};\n\nKtdGridService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: KtdGridService,\n  factory: KtdGridService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(KtdGridService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.NgZone\n    }];\n  }, null);\n})();\n\nclass KtdGridItemComponent {\n  constructor(elementRef, gridService, renderer, ngZone, getItemRenderData) {\n    this.elementRef = elementRef;\n    this.gridService = gridService;\n    this.renderer = renderer;\n    this.ngZone = ngZone;\n    this.getItemRenderData = getItemRenderData;\n    /** CSS transition style. Note that for more performance is preferable only make transition on transform property. */\n\n    this.transition = 'transform 500ms ease, width 500ms ease, height 500ms ease';\n    this._dragStartThreshold = 0;\n    this._draggable = true;\n    this._draggable$ = new BehaviorSubject(this._draggable);\n    this._resizable = true;\n    this._resizable$ = new BehaviorSubject(this._resizable);\n    this.dragStartSubject = new Subject();\n    this.resizeStartSubject = new Subject();\n    this.subscriptions = [];\n    this.dragStart$ = this.dragStartSubject.asObservable();\n    this.resizeStart$ = this.resizeStartSubject.asObservable();\n  }\n  /** Id of the grid item. This property is strictly compulsory. */\n\n\n  get id() {\n    return this._id;\n  }\n\n  set id(val) {\n    this._id = val;\n  }\n  /** Minimum amount of pixels that the user should move before it starts the drag sequence. */\n\n\n  get dragStartThreshold() {\n    return this._dragStartThreshold;\n  }\n\n  set dragStartThreshold(val) {\n    this._dragStartThreshold = coerceNumberProperty(val);\n  }\n  /** Whether the item is draggable or not. Defaults to true. */\n\n\n  get draggable() {\n    return this._draggable;\n  }\n\n  set draggable(val) {\n    this._draggable = coerceBooleanProperty(val);\n\n    this._draggable$.next(this._draggable);\n  }\n  /** Whether the item is resizable or not. Defaults to true. */\n\n\n  get resizable() {\n    return this._resizable;\n  }\n\n  set resizable(val) {\n    this._resizable = coerceBooleanProperty(val);\n\n    this._resizable$.next(this._resizable);\n  }\n\n  ngOnInit() {\n    const gridItemRenderData = this.getItemRenderData(this.id);\n    this.setStyles(gridItemRenderData);\n  }\n\n  ngAfterContentInit() {\n    this.subscriptions.push(this._dragStart$().subscribe(this.dragStartSubject), this._resizeStart$().subscribe(this.resizeStartSubject));\n  }\n\n  ngOnDestroy() {\n    this.subscriptions.forEach(sub => sub.unsubscribe());\n  }\n\n  setStyles({\n    top,\n    left,\n    width,\n    height\n  }) {\n    // transform is 6x times faster than top/left\n    this.renderer.setStyle(this.elementRef.nativeElement, 'transform', `translateX(${left}) translateY(${top})`);\n    this.renderer.setStyle(this.elementRef.nativeElement, 'display', `block`);\n    this.renderer.setStyle(this.elementRef.nativeElement, 'transition', this.transition);\n\n    if (width != null) {\n      this.renderer.setStyle(this.elementRef.nativeElement, 'width', width);\n    }\n\n    if (height != null) {\n      this.renderer.setStyle(this.elementRef.nativeElement, 'height', height);\n    }\n  }\n\n  _dragStart$() {\n    return this._draggable$.pipe(switchMap(draggable => {\n      if (!draggable) {\n        return NEVER;\n      } else {\n        return this._dragHandles.changes.pipe(startWith(this._dragHandles), switchMap(dragHandles => {\n          return iif(() => dragHandles.length > 0, merge(...dragHandles.toArray().map(dragHandle => ktdMouseOrTouchDown(dragHandle.element.nativeElement, 1))), ktdMouseOrTouchDown(this.elementRef.nativeElement, 1)).pipe(exhaustMap(startEvent => {\n            // If the event started from an element with the native HTML drag&drop, it'll interfere\n            // with our own dragging (e.g. `img` tags do it by default). Prevent the default action\n            // to stop it from happening. Note that preventing on `dragstart` also seems to work, but\n            // it's flaky and it fails if the user drags it away quickly. Also note that we only want\n            // to do this for `mousedown` since doing the same for `touchstart` will stop any `click`\n            // events from firing on touch devices.\n            if (startEvent.target && startEvent.target.draggable && startEvent.type === 'mousedown') {\n              startEvent.preventDefault();\n            }\n\n            const startPointer = ktdPointerClient(startEvent);\n            return this.gridService.mouseOrTouchMove$(document).pipe(takeUntil(ktdMouseOrTouchEnd(document, 1)), ktdOutsideZone(this.ngZone), filter(moveEvent => {\n              moveEvent.preventDefault();\n              const movePointer = ktdPointerClient(moveEvent);\n              const distanceX = Math.abs(startPointer.clientX - movePointer.clientX);\n              const distanceY = Math.abs(startPointer.clientY - movePointer.clientY); // When this conditions returns true mean that we are over threshold.\n\n              return distanceX + distanceY >= this.dragStartThreshold;\n            }), take(1), // Return the original start event\n            map(() => startEvent));\n          }));\n        }));\n      }\n    }));\n  }\n\n  _resizeStart$() {\n    return this._resizable$.pipe(switchMap(resizable => {\n      if (!resizable) {\n        // Side effect to hide the resizeElem if resize is disabled.\n        this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'none');\n        return NEVER;\n      } else {\n        return this._resizeHandles.changes.pipe(startWith(this._resizeHandles), switchMap(resizeHandles => {\n          if (resizeHandles.length > 0) {\n            // Side effect to hide the resizeElem if there are resize handles.\n            this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'none');\n            return merge(...resizeHandles.toArray().map(resizeHandle => ktdMouseOrTouchDown(resizeHandle.element.nativeElement, 1)));\n          } else {\n            this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'block');\n            return ktdMouseOrTouchDown(this.resizeElem.nativeElement, 1);\n          }\n        }));\n      }\n    }));\n  }\n\n}\n\nKtdGridItemComponent.ɵfac = function KtdGridItemComponent_Factory(t) {\n  return new (t || KtdGridItemComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(KtdGridService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(GRID_ITEM_GET_RENDER_DATA_TOKEN));\n};\n\nKtdGridItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: KtdGridItemComponent,\n  selectors: [[\"ktd-grid-item\"]],\n  contentQueries: function KtdGridItemComponent_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      i0.ɵɵcontentQuery(dirIndex, KTD_GRID_DRAG_HANDLE, 5);\n      i0.ɵɵcontentQuery(dirIndex, KTD_GRID_RESIZE_HANDLE, 5);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._dragHandles = _t);\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._resizeHandles = _t);\n    }\n  },\n  viewQuery: function KtdGridItemComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵviewQuery(_c0, 7, ElementRef);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.resizeElem = _t.first);\n    }\n  },\n  inputs: {\n    minW: \"minW\",\n    minH: \"minH\",\n    maxW: \"maxW\",\n    maxH: \"maxH\",\n    transition: \"transition\",\n    id: \"id\",\n    dragStartThreshold: \"dragStartThreshold\",\n    draggable: \"draggable\",\n    resizable: \"resizable\"\n  },\n  ngContentSelectors: _c1,\n  decls: 3,\n  vars: 0,\n  consts: [[1, \"grid-item-resize-icon\"], [\"resizeElem\", \"\"]],\n  template: function KtdGridItemComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef();\n      i0.ɵɵprojection(0);\n      i0.ɵɵelement(1, \"div\", 0, 1);\n    }\n  },\n  styles: [\"[_nghost-%COMP%]{display:none;position:absolute;z-index:1;overflow:hidden}[_nghost-%COMP%]   div[_ngcontent-%COMP%]{position:absolute;-webkit-user-select:none;user-select:none;z-index:10}[_nghost-%COMP%]   div.grid-item-resize-icon[_ngcontent-%COMP%]{cursor:se-resize;width:20px;height:20px;bottom:0;right:0;color:inherit}[_nghost-%COMP%]   div.grid-item-resize-icon[_ngcontent-%COMP%]:after{content:\\\"\\\";position:absolute;right:3px;bottom:3px;width:5px;height:5px;border-right:2px solid;border-bottom:2px solid}.display-none[_ngcontent-%COMP%]{display:none!important}\"],\n  changeDetection: 0\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(KtdGridItemComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ktd-grid-item',\n      templateUrl: './grid-item.component.html',\n      styleUrls: ['./grid-item.component.scss'],\n      changeDetection: ChangeDetectionStrategy.OnPush\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: KtdGridService\n    }, {\n      type: i0.Renderer2\n    }, {\n      type: i0.NgZone\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [GRID_ITEM_GET_RENDER_DATA_TOKEN]\n      }]\n    }];\n  }, {\n    _dragHandles: [{\n      type: ContentChildren,\n      args: [KTD_GRID_DRAG_HANDLE, {\n        descendants: true\n      }]\n    }],\n    _resizeHandles: [{\n      type: ContentChildren,\n      args: [KTD_GRID_RESIZE_HANDLE, {\n        descendants: true\n      }]\n    }],\n    resizeElem: [{\n      type: ViewChild,\n      args: ['resizeElem', {\n        static: true,\n        read: ElementRef\n      }]\n    }],\n    minW: [{\n      type: Input\n    }],\n    minH: [{\n      type: Input\n    }],\n    maxW: [{\n      type: Input\n    }],\n    maxH: [{\n      type: Input\n    }],\n    transition: [{\n      type: Input\n    }],\n    id: [{\n      type: Input\n    }],\n    dragStartThreshold: [{\n      type: Input\n    }],\n    draggable: [{\n      type: Input\n    }],\n    resizable: [{\n      type: Input\n    }]\n  });\n})(); // tslint:disable\n\n/**\r\n * Client rect utilities.\r\n * This file is taken from Angular Material repository. This is the reason why the tslint is disabled on this case.\r\n * Don't enable it until some custom change is done on this file.\r\n */\n\n/** Gets a mutable version of an element's bounding `ClientRect`. */\n\n\nfunction getMutableClientRect(element) {\n  const clientRect = element.getBoundingClientRect(); // We need to clone the `clientRect` here, because all the values on it are readonly\n  // and we need to be able to update them. Also we can't use a spread here, because\n  // the values on a `ClientRect` aren't own properties. See:\n  // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\n\n  return {\n    top: clientRect.top,\n    right: clientRect.right,\n    bottom: clientRect.bottom,\n    left: clientRect.left,\n    width: clientRect.width,\n    height: clientRect.height\n  };\n}\n/**\r\n * Checks whether some coordinates are within a `ClientRect`.\r\n * @param clientRect ClientRect that is being checked.\r\n * @param x Coordinates along the X axis.\r\n * @param y Coordinates along the Y axis.\r\n */\n\n\nfunction isInsideClientRect(clientRect, x, y) {\n  const {\n    top,\n    bottom,\n    left,\n    right\n  } = clientRect;\n  return y >= top && y <= bottom && x >= left && x <= right;\n}\n/**\r\n * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\r\n * @param clientRect `ClientRect` that should be updated.\r\n * @param top Amount to add to the `top` position.\r\n * @param left Amount to add to the `left` position.\r\n */\n\n\nfunction adjustClientRect(clientRect, top, left) {\n  clientRect.top += top;\n  clientRect.bottom = clientRect.top + clientRect.height;\n  clientRect.left += left;\n  clientRect.right = clientRect.left + clientRect.width;\n}\n/**\r\n * Checks whether the pointer coordinates are close to a ClientRect.\r\n * @param rect ClientRect to check against.\r\n * @param threshold Threshold around the ClientRect.\r\n * @param pointerX Coordinates along the X axis.\r\n * @param pointerY Coordinates along the Y axis.\r\n */\n\n\nfunction isPointerNearClientRect(rect, threshold, pointerX, pointerY) {\n  const {\n    top,\n    right,\n    bottom,\n    left,\n    width,\n    height\n  } = rect;\n  const xThreshold = width * threshold;\n  const yThreshold = height * threshold;\n  return pointerY > top - yThreshold && pointerY < bottom + yThreshold && pointerX > left - xThreshold && pointerX < right + xThreshold;\n}\n/**\r\n * Proximity, as a ratio to width/height at which to start auto-scrolling.\r\n * The value comes from trying it out manually until it feels right.\r\n */\n\n\nconst SCROLL_PROXIMITY_THRESHOLD = 0.05;\n/**\r\n * Increments the vertical scroll position of a node.\r\n * @param node Node whose scroll position should change.\r\n * @param amount Amount of pixels that the `node` should be scrolled.\r\n */\n\nfunction incrementVerticalScroll(node, amount) {\n  if (node === window) {\n    node.scrollBy(0, amount);\n  } else {\n    // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n    node.scrollTop += amount;\n  }\n}\n/**\r\n * Increments the horizontal scroll position of a node.\r\n * @param node Node whose scroll position should change.\r\n * @param amount Amount of pixels that the `node` should be scrolled.\r\n */\n\n\nfunction incrementHorizontalScroll(node, amount) {\n  if (node === window) {\n    node.scrollBy(amount, 0);\n  } else {\n    // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n    node.scrollLeft += amount;\n  }\n}\n/**\r\n * Gets whether the vertical auto-scroll direction of a node.\r\n * @param clientRect Dimensions of the node.\r\n * @param pointerY Position of the user's pointer along the y axis.\r\n */\n\n\nfunction getVerticalScrollDirection(clientRect, pointerY) {\n  const {\n    top,\n    bottom,\n    height\n  } = clientRect;\n  const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;\n\n  if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {\n    return 1\n    /* UP */\n    ;\n  } else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {\n    return 2\n    /* DOWN */\n    ;\n  }\n\n  return 0\n  /* NONE */\n  ;\n}\n/**\r\n * Gets whether the horizontal auto-scroll direction of a node.\r\n * @param clientRect Dimensions of the node.\r\n * @param pointerX Position of the user's pointer along the x axis.\r\n */\n\n\nfunction getHorizontalScrollDirection(clientRect, pointerX) {\n  const {\n    left,\n    right,\n    width\n  } = clientRect;\n  const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;\n\n  if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {\n    return 1\n    /* LEFT */\n    ;\n  } else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {\n    return 2\n    /* RIGHT */\n    ;\n  }\n\n  return 0\n  /* NONE */\n  ;\n}\n/**\r\n * Returns an observable that schedules a loop and apply scroll on the scrollNode into the specified direction/s.\r\n * This observable doesn't emit, it just performs the 'scroll' side effect.\r\n * @param scrollNode, node where the scroll would be applied.\r\n * @param verticalScrollDirection, vertical direction of the scroll.\r\n * @param horizontalScrollDirection, horizontal direction of the scroll.\r\n * @param scrollStep, scroll step in CSS pixels that would be applied in every loop.\r\n */\n\n\nfunction scrollToDirectionInterval$(scrollNode, verticalScrollDirection, horizontalScrollDirection, scrollStep = 2) {\n  return interval(0, animationFrameScheduler).pipe(tap(() => {\n    if (verticalScrollDirection === 1\n    /* UP */\n    ) {\n      incrementVerticalScroll(scrollNode, -scrollStep);\n    } else if (verticalScrollDirection === 2\n    /* DOWN */\n    ) {\n      incrementVerticalScroll(scrollNode, scrollStep);\n    }\n\n    if (horizontalScrollDirection === 1\n    /* LEFT */\n    ) {\n      incrementHorizontalScroll(scrollNode, -scrollStep);\n    } else if (horizontalScrollDirection === 2\n    /* RIGHT */\n    ) {\n      incrementHorizontalScroll(scrollNode, scrollStep);\n    }\n  }), ktdNoEmit());\n}\n/**\r\n * Given a source$ observable with pointer location, scroll the scrollNode if the pointer is near to it.\r\n * This observable doesn't emit, it just performs a 'scroll' side effect.\r\n * @param scrollableParent, parent node in which the scroll would be performed.\r\n * @param options, configuration options.\r\n */\n\n\nfunction ktdScrollIfNearElementClientRect$(scrollableParent, options) {\n  let scrollNode;\n  let scrollableParentClientRect;\n  let scrollableParentScrollWidth;\n\n  if (scrollableParent === document) {\n    scrollNode = document.defaultView;\n    const {\n      width,\n      height\n    } = getViewportSize();\n    scrollableParentClientRect = {\n      width,\n      height,\n      top: 0,\n      right: width,\n      bottom: height,\n      left: 0\n    };\n    scrollableParentScrollWidth = getDocumentScrollWidth();\n  } else {\n    scrollNode = scrollableParent;\n    scrollableParentClientRect = getMutableClientRect(scrollableParent);\n    scrollableParentScrollWidth = scrollableParent.scrollWidth;\n  }\n  /**\r\n   * IMPORTANT: By design, only let scroll horizontal if the scrollable parent has explicitly an scroll horizontal.\r\n   * This layout solution is not designed in mind to have any scroll horizontal, but exceptionally we allow it in this\r\n   * specific use case.\r\n   */\n\n\n  options = options || {};\n\n  if (options.disableHorizontal == null && scrollableParentScrollWidth <= scrollableParentClientRect.width) {\n    options.disableHorizontal = true;\n  }\n\n  return source$ => source$.pipe(map(({\n    pointerX,\n    pointerY\n  }) => {\n    let verticalScrollDirection = getVerticalScrollDirection(scrollableParentClientRect, pointerY);\n    let horizontalScrollDirection = getHorizontalScrollDirection(scrollableParentClientRect, pointerX); // Check if scroll directions are disabled.\n\n    if (options === null || options === void 0 ? void 0 : options.disableVertical) {\n      verticalScrollDirection = 0\n      /* NONE */\n      ;\n    }\n\n    if (options === null || options === void 0 ? void 0 : options.disableHorizontal) {\n      horizontalScrollDirection = 0\n      /* NONE */\n      ;\n    }\n\n    return {\n      verticalScrollDirection,\n      horizontalScrollDirection\n    };\n  }), distinctUntilChanged((prev, actual) => {\n    return prev.verticalScrollDirection === actual.verticalScrollDirection && prev.horizontalScrollDirection === actual.horizontalScrollDirection;\n  }), switchMap(({\n    verticalScrollDirection,\n    horizontalScrollDirection\n  }) => {\n    if (verticalScrollDirection || horizontalScrollDirection) {\n      return scrollToDirectionInterval$(scrollNode, verticalScrollDirection, horizontalScrollDirection, options === null || options === void 0 ? void 0 : options.scrollStep);\n    } else {\n      return NEVER;\n    }\n  }));\n}\n/**\r\n * Emits on EVERY scroll event and returns the accumulated scroll offset relative to the initial scroll position.\r\n * @param scrollableParent, node in which scroll events would be listened.\r\n */\n\n\nfunction ktdGetScrollTotalRelativeDifference$(scrollableParent) {\n  let scrollInitialPosition; // Calculate initial scroll position\n\n  if (scrollableParent === document) {\n    scrollInitialPosition = getViewportScrollPosition();\n  } else {\n    scrollInitialPosition = {\n      top: scrollableParent.scrollTop,\n      left: scrollableParent.scrollLeft\n    };\n  }\n\n  return fromEvent(scrollableParent, 'scroll', ktdNormalizePassiveListenerOptions({\n    capture: true\n  })).pipe(map(() => {\n    let newTop;\n    let newLeft;\n\n    if (scrollableParent === document) {\n      const viewportScrollPosition = getViewportScrollPosition();\n      newTop = viewportScrollPosition.top;\n      newLeft = viewportScrollPosition.left;\n    } else {\n      newTop = scrollableParent.scrollTop;\n      newLeft = scrollableParent.scrollLeft;\n    }\n\n    const topDifference = scrollInitialPosition.top - newTop;\n    const leftDifference = scrollInitialPosition.left - newLeft;\n    return {\n      top: topDifference,\n      left: leftDifference\n    };\n  }));\n}\n/** Returns the viewport's width and height. */\n\n\nfunction getViewportSize() {\n  const _window = document.defaultView || window;\n\n  return {\n    width: _window.innerWidth,\n    height: _window.innerHeight\n  };\n}\n/** Gets a ClientRect for the viewport's bounds. */\n\n\nfunction getViewportRect() {\n  // Use the document element's bounding rect rather than the window scroll properties\n  // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n  // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n  // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n  // can disagree when the page is pinch-zoomed (on devices that support touch).\n  // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n  // We use the documentElement instead of the body because, by default (without a css reset)\n  // browsers typically give the document body an 8px margin, which is not included in\n  // getBoundingClientRect().\n  const scrollPosition = getViewportScrollPosition();\n  const {\n    width,\n    height\n  } = getViewportSize();\n  return {\n    top: scrollPosition.top,\n    left: scrollPosition.left,\n    bottom: scrollPosition.top + height,\n    right: scrollPosition.left + width,\n    height,\n    width\n  };\n}\n/** Gets the (top, left) scroll position of the viewport. */\n\n\nfunction getViewportScrollPosition() {\n  // The top-left-corner of the viewport is determined by the scroll position of the document\n  // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n  // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n  // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n  // `document.documentElement` works consistently, where the `top` and `left` values will\n  // equal negative the scroll position.\n  const windowRef = document.defaultView || window;\n  const documentElement = document.documentElement;\n  const documentRect = documentElement.getBoundingClientRect();\n  const top = -documentRect.top || document.body.scrollTop || windowRef.scrollY || documentElement.scrollTop || 0;\n  const left = -documentRect.left || document.body.scrollLeft || windowRef.scrollX || documentElement.scrollLeft || 0;\n  return {\n    top,\n    left\n  };\n}\n/** Returns the document scroll width */\n\n\nfunction getDocumentScrollWidth() {\n  return Math.max(document.body.scrollWidth, document.documentElement.scrollWidth);\n}\n\nfunction getDragResizeEventData(gridItem, layout) {\n  return {\n    layout,\n    layoutItem: layout.find(item => item.id === gridItem.id),\n    gridItemRef: gridItem\n  };\n}\n\nfunction layoutToRenderItems(config, width, height) {\n  const {\n    cols,\n    rowHeight,\n    layout\n  } = config;\n  const renderItems = {};\n\n  for (const item of layout) {\n    renderItems[item.id] = {\n      id: item.id,\n      top: item.y === 0 ? 0 : item.y * rowHeight,\n      left: item.x * (width / cols),\n      width: item.w * (width / cols),\n      height: item.h * rowHeight\n    };\n  }\n\n  return renderItems;\n}\n\nfunction getGridHeight(layout, rowHeight) {\n  return layout.reduce((acc, cur) => Math.max(acc, (cur.y + cur.h) * rowHeight), 0);\n} // tslint:disable-next-line\n\n\nfunction parseRenderItemToPixels(renderItem) {\n  return {\n    id: renderItem.id,\n    top: `${renderItem.top}px`,\n    left: `${renderItem.left}px`,\n    width: `${renderItem.width}px`,\n    height: `${renderItem.height}px`\n  };\n} // tslint:disable-next-line:ktd-prefix-code\n\n\nfunction __gridItemGetRenderDataFactoryFunc(gridCmp) {\n  // tslint:disable-next-line:only-arrow-functions\n  return function (id) {\n    return parseRenderItemToPixels(gridCmp.getItemRenderData(id));\n  };\n}\n\nfunction ktdGridItemGetRenderDataFactoryFunc(gridCmp) {\n  // Workaround explained: https://github.com/ng-packagr/ng-packagr/issues/696#issuecomment-387114613\n  const resultFunc = __gridItemGetRenderDataFactoryFunc(gridCmp);\n\n  return resultFunc;\n}\n\nclass KtdGridComponent {\n  constructor(gridService, elementRef, renderer, ngZone) {\n    this.gridService = gridService;\n    this.elementRef = elementRef;\n    this.renderer = renderer;\n    this.ngZone = ngZone;\n    /** Emits when layout change */\n\n    this.layoutUpdated = new EventEmitter();\n    /** Emits when drag starts */\n\n    this.dragStarted = new EventEmitter();\n    /** Emits when resize starts */\n\n    this.resizeStarted = new EventEmitter();\n    /** Emits when drag ends */\n\n    this.dragEnded = new EventEmitter();\n    /** Emits when resize ends */\n\n    this.resizeEnded = new EventEmitter();\n    /**\r\n     * Parent element that contains the scroll. If an string is provided it would search that element by id on the dom.\r\n     * If no data provided or null autoscroll is not performed.\r\n     */\n\n    this.scrollableParent = null;\n    this._compactOnPropsChange = true;\n    this._preventCollision = false;\n    this._scrollSpeed = 2;\n    this._compactType = 'vertical';\n    this._rowHeight = 100;\n    this._cols = 6;\n  }\n  /** Whether or not to update the internal layout when some dependent property change. */\n\n\n  get compactOnPropsChange() {\n    return this._compactOnPropsChange;\n  }\n\n  set compactOnPropsChange(value) {\n    this._compactOnPropsChange = coerceBooleanProperty(value);\n  }\n  /** If true, grid items won't change position when being dragged over. Handy when using no compaction */\n\n\n  get preventCollision() {\n    return this._preventCollision;\n  }\n\n  set preventCollision(value) {\n    this._preventCollision = coerceBooleanProperty(value);\n  }\n  /** Number of CSS pixels that would be scrolled on each 'tick' when auto scroll is performed. */\n\n\n  get scrollSpeed() {\n    return this._scrollSpeed;\n  }\n\n  set scrollSpeed(value) {\n    this._scrollSpeed = coerceNumberProperty(value, 2);\n  }\n  /** Type of compaction that will be applied to the layout (vertical, horizontal or free). Defaults to 'vertical' */\n\n\n  get compactType() {\n    return this._compactType;\n  }\n\n  set compactType(val) {\n    this._compactType = val;\n  }\n  /** Row height in css pixels */\n\n\n  get rowHeight() {\n    return this._rowHeight;\n  }\n\n  set rowHeight(val) {\n    this._rowHeight = Math.max(1, Math.round(coerceNumberProperty(val)));\n  }\n  /** Number of columns  */\n\n\n  get cols() {\n    return this._cols;\n  }\n\n  set cols(val) {\n    this._cols = Math.max(1, Math.round(coerceNumberProperty(val)));\n  }\n  /** Layout of the grid. Array of all the grid items with its 'id' and position on the grid. */\n\n\n  get layout() {\n    return this._layout;\n  }\n\n  set layout(layout) {\n    /**\r\n     * Enhancement:\r\n     * Only set layout if it's reference has changed and use a boolean to track whenever recalculate the layout on ngOnChanges.\r\n     *\r\n     * Why:\r\n     * The normal use of this lib is having the variable layout in the outer component or in a store, assigning it whenever it changes and\r\n     * binded in the component with it's input [layout]. In this scenario, we would always calculate one unnecessary change on the layout when\r\n     * it is re-binded on the input.\r\n     */\n    this._layout = layout;\n  }\n\n  get config() {\n    return {\n      cols: this.cols,\n      rowHeight: this.rowHeight,\n      layout: this.layout,\n      preventCollision: this.preventCollision\n    };\n  }\n\n  ngOnChanges(changes) {\n    let needsCompactLayout = false;\n    let needsRecalculateRenderData = false; // TODO: Does fist change need to be compacted by default?\n    // Compact layout whenever some dependent prop changes.\n\n    if (changes.compactType || changes.cols || changes.layout) {\n      needsCompactLayout = true;\n    } // Check if wee need to recalculate rendering data.\n\n\n    if (needsCompactLayout || changes.rowHeight) {\n      needsRecalculateRenderData = true;\n    } // Only compact layout if lib user has provided it. Lib users that want to save/store always the same layout  as it is represented (compacted)\n    // can use KtdCompactGrid utility and pre-compact the layout. This is the recommended behaviour for always having a the same layout on this component\n    // and the ones that uses it.\n\n\n    if (needsCompactLayout && this.compactOnPropsChange) {\n      this.compactLayout();\n    }\n\n    if (needsRecalculateRenderData) {\n      this.calculateRenderData();\n    }\n  }\n\n  ngAfterContentInit() {\n    this.initSubscriptions();\n  }\n\n  ngAfterContentChecked() {\n    this.render();\n  }\n\n  resize() {\n    this.calculateRenderData();\n    this.render();\n  }\n\n  ngOnDestroy() {\n    this.subscriptions.forEach(sub => sub.unsubscribe());\n  }\n\n  compactLayout() {\n    this.layout = compact(this.layout, this.compactType, this.cols);\n  }\n\n  getItemsRenderData() {\n    return Object.assign({}, this._gridItemsRenderData);\n  }\n\n  getItemRenderData(itemId) {\n    return this._gridItemsRenderData[itemId];\n  }\n\n  calculateRenderData() {\n    const clientRect = this.elementRef.nativeElement.getBoundingClientRect();\n    this._gridItemsRenderData = layoutToRenderItems(this.config, clientRect.width, clientRect.height);\n    this._height = getGridHeight(this.layout, this.rowHeight);\n  }\n\n  render() {\n    this.renderer.setStyle(this.elementRef.nativeElement, 'height', `${this._height}px`);\n    this.updateGridItemsStyles();\n  }\n\n  updateGridItemsStyles() {\n    this._gridItems.forEach(item => {\n      const gridItemRenderData = this._gridItemsRenderData[item.id];\n\n      if (gridItemRenderData == null) {\n        console.error(`Couldn\\'t find the specified grid item for the id: ${item.id}`);\n      } else {\n        item.setStyles(parseRenderItemToPixels(gridItemRenderData));\n      }\n    });\n  }\n\n  initSubscriptions() {\n    this.subscriptions = [this._gridItems.changes.pipe(startWith(this._gridItems), switchMap(gridItems => {\n      return merge(...gridItems.map(gridItem => gridItem.dragStart$.pipe(map(event => ({\n        event,\n        gridItem,\n        type: 'drag'\n      })))), ...gridItems.map(gridItem => gridItem.resizeStart$.pipe(map(event => ({\n        event,\n        gridItem,\n        type: 'resize'\n      }))))).pipe(exhaustMap(({\n        event,\n        gridItem,\n        type\n      }) => {\n        // Emit drag or resize start events. Ensure that is start event is inside the zone.\n        this.ngZone.run(() => (type === 'drag' ? this.dragStarted : this.resizeStarted).emit(getDragResizeEventData(gridItem, this.layout))); // Get the correct newStateFunc depending on if we are dragging or resizing\n\n        const calcNewStateFunc = type === 'drag' ? ktdGridItemDragging : ktdGridItemResizing; // Perform drag sequence\n\n        return this.performDragSequence$(gridItem, event, (gridItemId, config, compactionType, draggingData) => calcNewStateFunc(gridItem, config, compactionType, draggingData)).pipe(map(layout => ({\n          layout,\n          gridItem,\n          type\n        })));\n      }));\n    })).subscribe(({\n      layout,\n      gridItem,\n      type\n    }) => {\n      this.layout = layout; // Calculate new rendering data given the new layout.\n\n      this.calculateRenderData(); // Emit drag or resize end events.\n\n      (type === 'drag' ? this.dragEnded : this.resizeEnded).emit(getDragResizeEventData(gridItem, layout)); // Notify that the layout has been updated.\n\n      this.layoutUpdated.emit(layout);\n    })];\n  }\n  /**\r\n   * Perform a general grid drag action, from start to end. A general grid drag action basically includes creating the placeholder element and adding\r\n   * some class animations. calcNewStateFunc needs to be provided in order to calculate the new state of the layout.\r\n   * @param gridItem that is been dragged\r\n   * @param pointerDownEvent event (mousedown or touchdown) where the user initiated the drag\r\n   * @param calcNewStateFunc function that return the new layout state and the drag element position\r\n   */\n\n\n  performDragSequence$(gridItem, pointerDownEvent, calcNewStateFunc) {\n    return new Observable(observer => {\n      // Retrieve grid (parent) and gridItem (draggedElem) client rects.\n      const gridElemClientRect = getMutableClientRect(this.elementRef.nativeElement);\n      const dragElemClientRect = getMutableClientRect(gridItem.elementRef.nativeElement);\n      const scrollableParent = typeof this.scrollableParent === 'string' ? document.getElementById(this.scrollableParent) : this.scrollableParent;\n      this.renderer.addClass(gridItem.elementRef.nativeElement, 'no-transitions');\n      this.renderer.addClass(gridItem.elementRef.nativeElement, 'ktd-grid-item-dragging'); // Create placeholder element. This element would represent the position where the dragged/resized element would be if the action ends\n\n      const placeholderElement = this.renderer.createElement('div');\n      placeholderElement.style.width = `${dragElemClientRect.width}px`;\n      placeholderElement.style.height = `${dragElemClientRect.height}px`;\n      placeholderElement.style.transform = `translateX(${dragElemClientRect.left - gridElemClientRect.left}px) translateY(${dragElemClientRect.top - gridElemClientRect.top}px)`;\n      this.renderer.addClass(placeholderElement, 'ktd-grid-item-placeholder');\n      this.renderer.appendChild(this.elementRef.nativeElement, placeholderElement);\n      let newLayout; // TODO (enhancement): consider move this 'side effect' observable inside the main drag loop.\n      //  - Pros are that we would not repeat subscriptions and takeUntil would shut down observables at the same time.\n      //  - Cons are that moving this functionality as a side effect inside the main drag loop would be confusing.\n\n      const scrollSubscription = this.ngZone.runOutsideAngular(() => (!scrollableParent ? NEVER : this.gridService.mouseOrTouchMove$(document).pipe(map(event => ({\n        pointerX: ktdPointerClientX(event),\n        pointerY: ktdPointerClientY(event)\n      })), ktdScrollIfNearElementClientRect$(scrollableParent, {\n        scrollStep: this.scrollSpeed\n      }))).pipe(takeUntil(ktdMouseOrTouchEnd(document))).subscribe());\n      /**\r\n       * Main subscription, it listens for 'pointer move' and 'scroll' events and recalculates the layout on each emission\r\n       */\n\n      const subscription = this.ngZone.runOutsideAngular(() => merge(combineLatest([this.gridService.mouseOrTouchMove$(document), ...(!scrollableParent ? [of({\n        top: 0,\n        left: 0\n      })] : [ktdGetScrollTotalRelativeDifference$(scrollableParent).pipe(startWith({\n        top: 0,\n        left: 0\n      }) // Force first emission to allow CombineLatest to emit even no scroll event has occurred\n      )])])).pipe(takeUntil(ktdMouseOrTouchEnd(document))).subscribe(([pointerDragEvent, scrollDifference]) => {\n        pointerDragEvent.preventDefault();\n        /**\r\n         * Set the new layout to be the layout in which the calcNewStateFunc would be executed.\r\n         * NOTE: using the mutated layout is the way to go by 'react-grid-layout' utils. If we don't use the previous layout,\r\n         * some utilities from 'react-grid-layout' would not work as expected.\r\n         */\n\n        const currentLayout = newLayout || this.layout;\n        const {\n          layout,\n          draggedItemPos\n        } = calcNewStateFunc(gridItem, {\n          layout: currentLayout,\n          rowHeight: this.rowHeight,\n          cols: this.cols,\n          preventCollision: this.preventCollision\n        }, this.compactType, {\n          pointerDownEvent,\n          pointerDragEvent,\n          gridElemClientRect,\n          dragElemClientRect,\n          scrollDifference\n        });\n        newLayout = layout;\n        this._height = getGridHeight(newLayout, this.rowHeight);\n        this._gridItemsRenderData = layoutToRenderItems({\n          cols: this.cols,\n          rowHeight: this.rowHeight,\n          layout: newLayout,\n          preventCollision: this.preventCollision\n        }, gridElemClientRect.width, gridElemClientRect.height);\n        const placeholderStyles = parseRenderItemToPixels(this._gridItemsRenderData[gridItem.id]); // Put the real final position to the placeholder element\n\n        placeholderElement.style.width = placeholderStyles.width;\n        placeholderElement.style.height = placeholderStyles.height;\n        placeholderElement.style.transform = `translateX(${placeholderStyles.left}) translateY(${placeholderStyles.top})`; // modify the position of the dragged item to be the once we want (for example the mouse position or whatever)\n\n        this._gridItemsRenderData[gridItem.id] = Object.assign(Object.assign({}, draggedItemPos), {\n          id: this._gridItemsRenderData[gridItem.id].id\n        });\n        this.render();\n      }, error => observer.error(error), () => {\n        this.ngZone.run(() => {\n          // Remove drag classes\n          this.renderer.removeClass(gridItem.elementRef.nativeElement, 'no-transitions');\n          this.renderer.removeClass(gridItem.elementRef.nativeElement, 'ktd-grid-item-dragging'); // Remove placeholder element from the dom\n          // NOTE: If we don't put the removeChild inside the zone it would not work... This may be a bug from angular or maybe is the intended behaviour, although strange.\n          // It should work since AFAIK this action should not be done in a CD cycle.\n\n          this.renderer.removeChild(this.elementRef.nativeElement, placeholderElement);\n\n          if (newLayout) {\n            // TODO: newLayout should already be pruned. If not, it should have type Layout, not KtdGridLayout as it is now.\n            // Prune react-grid-layout compact extra properties.\n            observer.next(newLayout.map(item => ({\n              id: item.id,\n              x: item.x,\n              y: item.y,\n              w: item.w,\n              h: item.h,\n              minW: item.minW,\n              minH: item.minH,\n              maxW: item.maxW,\n              maxH: item.maxH\n            })));\n          } else {\n            // TODO: Need we really to emit if there is no layout change but drag started and ended?\n            observer.next(this.layout);\n          }\n\n          observer.complete();\n        });\n      }));\n      return () => {\n        scrollSubscription.unsubscribe();\n        subscription.unsubscribe();\n      };\n    });\n  }\n\n}\n\nKtdGridComponent.ɵfac = function KtdGridComponent_Factory(t) {\n  return new (t || KtdGridComponent)(i0.ɵɵdirectiveInject(KtdGridService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nKtdGridComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: KtdGridComponent,\n  selectors: [[\"ktd-grid\"]],\n  contentQueries: function KtdGridComponent_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      i0.ɵɵcontentQuery(dirIndex, KtdGridItemComponent, 5);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._gridItems = _t);\n    }\n  },\n  inputs: {\n    scrollableParent: \"scrollableParent\",\n    compactOnPropsChange: \"compactOnPropsChange\",\n    preventCollision: \"preventCollision\",\n    scrollSpeed: \"scrollSpeed\",\n    compactType: \"compactType\",\n    rowHeight: \"rowHeight\",\n    cols: \"cols\",\n    layout: \"layout\"\n  },\n  outputs: {\n    layoutUpdated: \"layoutUpdated\",\n    dragStarted: \"dragStarted\",\n    resizeStarted: \"resizeStarted\",\n    dragEnded: \"dragEnded\",\n    resizeEnded: \"resizeEnded\"\n  },\n  features: [i0.ɵɵProvidersFeature([{\n    provide: GRID_ITEM_GET_RENDER_DATA_TOKEN,\n    useFactory: ktdGridItemGetRenderDataFactoryFunc,\n    deps: [KtdGridComponent]\n  }]), i0.ɵɵNgOnChangesFeature],\n  ngContentSelectors: _c1,\n  decls: 1,\n  vars: 0,\n  template: function KtdGridComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef();\n      i0.ɵɵprojection(0);\n    }\n  },\n  styles: [\"ktd-grid{display:block;position:relative;width:100%}ktd-grid ktd-grid-item.ktd-grid-item-dragging{z-index:1000}ktd-grid ktd-grid-item.no-transitions{transition:none!important}ktd-grid .ktd-grid-item-placeholder{position:absolute;background-color:#8b0000;opacity:.6;z-index:0;transition-property:transform;transition:all .15s ease}\\n\"],\n  encapsulation: 2,\n  changeDetection: 0\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(KtdGridComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ktd-grid',\n      templateUrl: './grid.component.html',\n      styleUrls: ['./grid.component.scss'],\n      encapsulation: ViewEncapsulation.None,\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      providers: [{\n        provide: GRID_ITEM_GET_RENDER_DATA_TOKEN,\n        useFactory: ktdGridItemGetRenderDataFactoryFunc,\n        deps: [KtdGridComponent]\n      }]\n    }]\n  }], function () {\n    return [{\n      type: KtdGridService\n    }, {\n      type: i0.ElementRef\n    }, {\n      type: i0.Renderer2\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    _gridItems: [{\n      type: ContentChildren,\n      args: [KtdGridItemComponent, {\n        descendants: true\n      }]\n    }],\n    layoutUpdated: [{\n      type: Output\n    }],\n    dragStarted: [{\n      type: Output\n    }],\n    resizeStarted: [{\n      type: Output\n    }],\n    dragEnded: [{\n      type: Output\n    }],\n    resizeEnded: [{\n      type: Output\n    }],\n    scrollableParent: [{\n      type: Input\n    }],\n    compactOnPropsChange: [{\n      type: Input\n    }],\n    preventCollision: [{\n      type: Input\n    }],\n    scrollSpeed: [{\n      type: Input\n    }],\n    compactType: [{\n      type: Input\n    }],\n    rowHeight: [{\n      type: Input\n    }],\n    cols: [{\n      type: Input\n    }],\n    layout: [{\n      type: Input\n    }]\n  });\n})();\n\nclass KtdGridModule {}\n\nKtdGridModule.ɵfac = function KtdGridModule_Factory(t) {\n  return new (t || KtdGridModule)();\n};\n\nKtdGridModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: KtdGridModule\n});\nKtdGridModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  providers: [KtdGridService],\n  imports: [[CommonModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(KtdGridModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [KtdGridComponent, KtdGridItemComponent, KtdGridDragHandle, KtdGridResizeHandle],\n      exports: [KtdGridComponent, KtdGridItemComponent, KtdGridDragHandle, KtdGridResizeHandle],\n      providers: [KtdGridService],\n      imports: [CommonModule]\n    }]\n  }], null, null);\n})();\n/*\r\n * Public API Surface of grid\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { GRID_ITEM_GET_RENDER_DATA_TOKEN, KTD_GRID_DRAG_HANDLE, KTD_GRID_RESIZE_HANDLE, KtdGridComponent, KtdGridDragHandle, KtdGridItemComponent, KtdGridModule, KtdGridResizeHandle, __gridItemGetRenderDataFactoryFunc, ktdGridCompact, ktdGridItemGetRenderDataFactoryFunc, ktdTrackById, parseRenderItemToPixels };","map":{"version":3,"sources":["C:/Users/gabri/Documents/GitHub/Base-Camp/ng-project/node_modules/@katoid/angular-grid-layout/fesm2015/katoid-angular-grid-layout.js"],"names":["iif","fromEvent","merge","Observable","Subject","BehaviorSubject","NEVER","interval","animationFrameScheduler","combineLatest","of","filter","switchMap","startWith","exhaustMap","takeUntil","take","map","tap","distinctUntilChanged","i0","InjectionToken","Directive","Injectable","ElementRef","Component","ChangeDetectionStrategy","Inject","ContentChildren","ViewChild","Input","EventEmitter","ViewEncapsulation","Output","NgModule","CommonModule","DEBUG","bottom","layout","max","bottomY","i","len","length","y","h","cloneLayout","newLayout","Array","cloneLayoutItem","layoutItem","clonedLayoutItem","w","x","id","moved","static","minW","undefined","maxW","minH","maxH","isDraggable","isResizable","collides","l1","l2","compact","compactType","cols","compareWith","getStatics","sorted","sortLayoutItems","out","l","compactItem","push","indexOf","heightWidth","resolveCompactionCollision","item","moveToCoord","axis","sizeProp","itemIndex","otherItem","fullLayout","compactV","compactH","Math","min","getFirstCollision","correctBounds","bounds","collidesWith","getLayoutItem","getAllCollisions","moveElement","isUserAction","preventCollision","log","String","oldX","oldY","movingUp","reverse","collisions","collision","moveElementAwayFromCollision","itemToMove","fakeItem","perc","num","setTransform","top","left","width","height","translate","transform","WebkitTransform","MozTransform","msTransform","OTransform","position","setTopLeft","sortLayoutItemsByColRow","sortLayoutItemsByRowCol","concat","sort","a","b","validateLayout","contextName","subProps","isArray","Error","j","autoBindHandlers","el","fns","forEach","key","bind","args","console","noop","supportsPassiveEvents","ktdSupportsPassiveEventListeners","window","addEventListener","Object","defineProperty","get","ktdNormalizePassiveListenerOptions","options","capture","passiveEventListenerOptions","passive","activeEventListenerOptions","isMobile","ktdIsMobileOrTablet","isMobileDevice","test","navigator","userAgent","isIOSMobileDevice","platform","maxTouchPoints","ktdIsMouseEvent","event","clientX","ktdIsTouchEvent","touches","ktdPointerClientX","ktdPointerClientY","clientY","ktdPointerClient","ktdMouseOrTouchDown","element","touchNumber","pipe","touchEvent","mouseEvent","button","ktdMouseOrTouchMove","ktdTouchEnd","ktdMouseOrTouchEnd","ktdTrackById","index","ktdGridCompact","screenXPosToGridValue","screenXPos","round","screenYPosToGridValue","screenYPos","rowHeight","ktdGetGridLayoutDiff","gridLayoutA","gridLayoutB","diff","itemA","itemB","find","_itemB","posChanged","sizeChanged","change","ktdGridItemDragging","gridItem","config","compactionType","draggingData","pointerDownEvent","pointerDragEvent","gridElemClientRect","dragElemClientRect","scrollDifference","gridItemId","draggingElemPrevItem","clientStartX","clientStartY","offsetX","offsetY","gridElementLeftPosition","gridElementTopPosition","gridRelXPos","gridRelYPos","assign","layoutItems","draggedLayoutItem","newLayoutItems","draggedItemPos","ktdGridItemResizing","_a","_b","_c","_d","resizeElemOffsetX","resizeElemOffsetY","limitNumberWithinRange","colliding","hasCollision","shrunkDimension","getDimensionToShrink","lastShrunk","Infinity","KTD_GRID_DRAG_HANDLE","KtdGridDragHandle","constructor","ɵfac","ɵdir","provide","useExisting","type","selector","host","class","providers","KTD_GRID_RESIZE_HANDLE","KtdGridResizeHandle","GRID_ITEM_GET_RENDER_DATA_TOKEN","ktdOutsideZone","zone","source","observer","runOutsideAngular","subscribe","ktdNoEmit","source$","coerceBooleanProperty","value","coerceNumberProperty","fallbackValue","_isNumberValue","Number","isNaN","parseFloat","activeCapturingEventOptions","KtdGridService","ngZone","touchMoveSubject","touchMove$","asObservable","registerTouchMoveSubscription","ngOnDestroy","touchMoveSubscription","unsubscribe","mouseOrTouchMove$","document","next","NgZone","ɵprov","providedIn","KtdGridItemComponent","elementRef","gridService","renderer","getItemRenderData","transition","_dragStartThreshold","_draggable","_draggable$","_resizable","_resizable$","dragStartSubject","resizeStartSubject","subscriptions","dragStart$","resizeStart$","_id","val","dragStartThreshold","draggable","resizable","ngOnInit","gridItemRenderData","setStyles","ngAfterContentInit","_dragStart$","_resizeStart$","sub","setStyle","nativeElement","_dragHandles","changes","dragHandles","toArray","dragHandle","startEvent","target","preventDefault","startPointer","moveEvent","movePointer","distanceX","abs","distanceY","resizeElem","_resizeHandles","resizeHandles","resizeHandle","Renderer2","ɵcmp","templateUrl","styleUrls","changeDetection","OnPush","decorators","descendants","read","getMutableClientRect","clientRect","getBoundingClientRect","right","isInsideClientRect","adjustClientRect","isPointerNearClientRect","rect","threshold","pointerX","pointerY","xThreshold","yThreshold","SCROLL_PROXIMITY_THRESHOLD","incrementVerticalScroll","node","amount","scrollBy","scrollTop","incrementHorizontalScroll","scrollLeft","getVerticalScrollDirection","getHorizontalScrollDirection","scrollToDirectionInterval$","scrollNode","verticalScrollDirection","horizontalScrollDirection","scrollStep","ktdScrollIfNearElementClientRect$","scrollableParent","scrollableParentClientRect","scrollableParentScrollWidth","defaultView","getViewportSize","getDocumentScrollWidth","scrollWidth","disableHorizontal","disableVertical","prev","actual","ktdGetScrollTotalRelativeDifference$","scrollInitialPosition","getViewportScrollPosition","newTop","newLeft","viewportScrollPosition","topDifference","leftDifference","_window","innerWidth","innerHeight","getViewportRect","scrollPosition","windowRef","documentElement","documentRect","body","scrollY","scrollX","getDragResizeEventData","gridItemRef","layoutToRenderItems","renderItems","getGridHeight","reduce","acc","cur","parseRenderItemToPixels","renderItem","__gridItemGetRenderDataFactoryFunc","gridCmp","ktdGridItemGetRenderDataFactoryFunc","resultFunc","KtdGridComponent","layoutUpdated","dragStarted","resizeStarted","dragEnded","resizeEnded","_compactOnPropsChange","_preventCollision","_scrollSpeed","_compactType","_rowHeight","_cols","compactOnPropsChange","scrollSpeed","_layout","ngOnChanges","needsCompactLayout","needsRecalculateRenderData","compactLayout","calculateRenderData","initSubscriptions","ngAfterContentChecked","render","resize","getItemsRenderData","_gridItemsRenderData","itemId","_height","updateGridItemsStyles","_gridItems","error","gridItems","run","emit","calcNewStateFunc","performDragSequence$","getElementById","addClass","placeholderElement","createElement","style","appendChild","scrollSubscription","subscription","currentLayout","placeholderStyles","removeClass","removeChild","complete","useFactory","deps","encapsulation","None","KtdGridModule","ɵmod","ɵinj","declarations","exports","imports"],"mappings":"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","sourcesContent":["import { iif, fromEvent, merge, Observable, Subject, BehaviorSubject, NEVER, interval, animationFrameScheduler, combineLatest, of } from 'rxjs';\nimport { filter, switchMap, startWith, exhaustMap, takeUntil, take, map, tap, distinctUntilChanged } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Directive, Injectable, ElementRef, Component, ChangeDetectionStrategy, Inject, ContentChildren, ViewChild, Input, EventEmitter, ViewEncapsulation, Output, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n/**\r\n * IMPORTANT:\r\n * This utils are taken from the project: https://github.com/STRML/react-grid-layout.\r\n * The code should be as less modified as possible for easy maintenance.\r\n */\r\nconst DEBUG = false;\r\n/**\r\n * Return the bottom coordinate of the layout.\r\n *\r\n * @param  {Array} layout Layout array.\r\n * @return {Number}       Bottom coordinate.\r\n */\r\nfunction bottom(layout) {\r\n    let max = 0, bottomY;\r\n    for (let i = 0, len = layout.length; i < len; i++) {\r\n        bottomY = layout[i].y + layout[i].h;\r\n        if (bottomY > max) {\r\n            max = bottomY;\r\n        }\r\n    }\r\n    return max;\r\n}\r\nfunction cloneLayout(layout) {\r\n    const newLayout = Array(layout.length);\r\n    for (let i = 0, len = layout.length; i < len; i++) {\r\n        newLayout[i] = cloneLayoutItem(layout[i]);\r\n    }\r\n    return newLayout;\r\n}\r\n// Fast path to cloning, since this is monomorphic\r\n/** NOTE: This code has been modified from the original source */\r\nfunction cloneLayoutItem(layoutItem) {\r\n    const clonedLayoutItem = {\r\n        w: layoutItem.w,\r\n        h: layoutItem.h,\r\n        x: layoutItem.x,\r\n        y: layoutItem.y,\r\n        id: layoutItem.id,\r\n        moved: !!layoutItem.moved,\r\n        static: !!layoutItem.static,\r\n    };\r\n    if (layoutItem.minW !== undefined) {\r\n        clonedLayoutItem.minW = layoutItem.minW;\r\n    }\r\n    if (layoutItem.maxW !== undefined) {\r\n        clonedLayoutItem.maxW = layoutItem.maxW;\r\n    }\r\n    if (layoutItem.minH !== undefined) {\r\n        clonedLayoutItem.minH = layoutItem.minH;\r\n    }\r\n    if (layoutItem.maxH !== undefined) {\r\n        clonedLayoutItem.maxH = layoutItem.maxH;\r\n    }\r\n    // These can be null\r\n    if (layoutItem.isDraggable !== undefined) {\r\n        clonedLayoutItem.isDraggable = layoutItem.isDraggable;\r\n    }\r\n    if (layoutItem.isResizable !== undefined) {\r\n        clonedLayoutItem.isResizable = layoutItem.isResizable;\r\n    }\r\n    return clonedLayoutItem;\r\n}\r\n/**\r\n * Given two layoutitems, check if they collide.\r\n */\r\nfunction collides(l1, l2) {\r\n    if (l1.id === l2.id) {\r\n        return false;\r\n    } // same element\r\n    if (l1.x + l1.w <= l2.x) {\r\n        return false;\r\n    } // l1 is left of l2\r\n    if (l1.x >= l2.x + l2.w) {\r\n        return false;\r\n    } // l1 is right of l2\r\n    if (l1.y + l1.h <= l2.y) {\r\n        return false;\r\n    } // l1 is above l2\r\n    if (l1.y >= l2.y + l2.h) {\r\n        return false;\r\n    } // l1 is below l2\r\n    return true; // boxes overlap\r\n}\r\n/**\r\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\r\n * between items.\r\n *\r\n * @param  {Array} layout Layout.\r\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\r\n *   vertically.\r\n * @return {Array}       Compacted Layout.\r\n */\r\nfunction compact(layout, compactType, cols) {\r\n    // Statics go in the compareWith array right away so items flow around them.\r\n    const compareWith = getStatics(layout);\r\n    // We go through the items by row and column.\r\n    const sorted = sortLayoutItems(layout, compactType);\r\n    // Holding for new items.\r\n    const out = Array(layout.length);\r\n    for (let i = 0, len = sorted.length; i < len; i++) {\r\n        let l = cloneLayoutItem(sorted[i]);\r\n        // Don't move static elements\r\n        if (!l.static) {\r\n            l = compactItem(compareWith, l, compactType, cols, sorted);\r\n            // Add to comparison array. We only collide with items before this one.\r\n            // Statics are already in this array.\r\n            compareWith.push(l);\r\n        }\r\n        // Add to output array to make sure they still come out in the right order.\r\n        out[layout.indexOf(sorted[i])] = l;\r\n        // Clear moved flag, if it exists.\r\n        l.moved = false;\r\n    }\r\n    return out;\r\n}\r\nconst heightWidth = { x: 'w', y: 'h' };\r\n/**\r\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\r\n */\r\nfunction resolveCompactionCollision(layout, item, moveToCoord, axis) {\r\n    const sizeProp = heightWidth[axis];\r\n    item[axis] += 1;\r\n    const itemIndex = layout\r\n        .map(layoutItem => {\r\n        return layoutItem.id;\r\n    })\r\n        .indexOf(item.id);\r\n    // Go through each item we collide with.\r\n    for (let i = itemIndex + 1; i < layout.length; i++) {\r\n        const otherItem = layout[i];\r\n        // Ignore static items\r\n        if (otherItem.static) {\r\n            continue;\r\n        }\r\n        // Optimization: we can break early if we know we're past this el\r\n        // We can do this b/c it's a sorted layout\r\n        if (otherItem.y > item.y + item.h) {\r\n            break;\r\n        }\r\n        if (collides(item, otherItem)) {\r\n            resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\r\n        }\r\n    }\r\n    item[axis] = moveToCoord;\r\n}\r\n/**\r\n * Compact an item in the layout.\r\n */\r\nfunction compactItem(compareWith, l, compactType, cols, fullLayout) {\r\n    const compactV = compactType === 'vertical';\r\n    const compactH = compactType === 'horizontal';\r\n    if (compactV) {\r\n        // Bottom 'y' possible is the bottom of the layout.\r\n        // This allows you to do nice stuff like specify {y: Infinity}\r\n        // This is here because the layout must be sorted in order to get the correct bottom `y`.\r\n        l.y = Math.min(bottom(compareWith), l.y);\r\n        // Move the element up as far as it can go without colliding.\r\n        while (l.y > 0 && !getFirstCollision(compareWith, l)) {\r\n            l.y--;\r\n        }\r\n    }\r\n    else if (compactH) {\r\n        l.y = Math.min(bottom(compareWith), l.y);\r\n        // Move the element left as far as it can go without colliding.\r\n        while (l.x > 0 && !getFirstCollision(compareWith, l)) {\r\n            l.x--;\r\n        }\r\n    }\r\n    // Move it down, and keep moving it down if it's colliding.\r\n    let collides;\r\n    while ((collides = getFirstCollision(compareWith, l))) {\r\n        if (compactH) {\r\n            resolveCompactionCollision(fullLayout, l, collides.x + collides.w, 'x');\r\n        }\r\n        else {\r\n            resolveCompactionCollision(fullLayout, l, collides.y + collides.h, 'y');\r\n        }\r\n        // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\r\n        if (compactH && l.x + l.w > cols) {\r\n            l.x = cols - l.w;\r\n            l.y++;\r\n        }\r\n    }\r\n    return l;\r\n}\r\n/**\r\n * Given a layout, make sure all elements fit within its bounds.\r\n *\r\n * @param  {Array} layout Layout array.\r\n * @param  {Number} bounds Number of columns.\r\n */\r\nfunction correctBounds(layout, bounds) {\r\n    const collidesWith = getStatics(layout);\r\n    for (let i = 0, len = layout.length; i < len; i++) {\r\n        const l = layout[i];\r\n        // Overflows right\r\n        if (l.x + l.w > bounds.cols) {\r\n            l.x = bounds.cols - l.w;\r\n        }\r\n        // Overflows left\r\n        if (l.x < 0) {\r\n            l.x = 0;\r\n            l.w = bounds.cols;\r\n        }\r\n        if (!l.static) {\r\n            collidesWith.push(l);\r\n        }\r\n        else {\r\n            // If this is static and collides with other statics, we must move it down.\r\n            // We have to do something nicer than just letting them overlap.\r\n            while (getFirstCollision(collidesWith, l)) {\r\n                l.y++;\r\n            }\r\n        }\r\n    }\r\n    return layout;\r\n}\r\n/**\r\n * Get a layout item by ID. Used so we can override later on if necessary.\r\n *\r\n * @param  {Array}  layout Layout array.\r\n * @param  {String} id     ID\r\n * @return {LayoutItem}    Item at ID.\r\n */\r\nfunction getLayoutItem(layout, id) {\r\n    for (let i = 0, len = layout.length; i < len; i++) {\r\n        if (layout[i].id === id) {\r\n            return layout[i];\r\n        }\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Returns the first item this layout collides with.\r\n * It doesn't appear to matter which order we approach this from, although\r\n * perhaps that is the wrong thing to do.\r\n *\r\n * @param  {Object} layoutItem Layout item.\r\n * @return {Object|undefined}  A colliding layout item, or undefined.\r\n */\r\nfunction getFirstCollision(layout, layoutItem) {\r\n    for (let i = 0, len = layout.length; i < len; i++) {\r\n        if (collides(layout[i], layoutItem)) {\r\n            return layout[i];\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction getAllCollisions(layout, layoutItem) {\r\n    return layout.filter(l => collides(l, layoutItem));\r\n}\r\n/**\r\n * Get all static elements.\r\n * @param  {Array} layout Array of layout objects.\r\n * @return {Array}        Array of static layout items..\r\n */\r\nfunction getStatics(layout) {\r\n    return layout.filter(l => l.static);\r\n}\r\n/**\r\n * Move an element. Responsible for doing cascading movements of other elements.\r\n *\r\n * @param  {Array}      layout            Full layout to modify.\r\n * @param  {LayoutItem} l                 element to move.\r\n * @param  {Number}     [x]               X position in grid units.\r\n * @param  {Number}     [y]               Y position in grid units.\r\n */\r\nfunction moveElement(layout, l, x, y, isUserAction, preventCollision, compactType, cols) {\r\n    // If this is static and not explicitly enabled as draggable,\r\n    // no move is possible, so we can short-circuit this immediately.\r\n    if (l.static && l.isDraggable !== true) {\r\n        return layout;\r\n    }\r\n    // Short-circuit if nothing to do.\r\n    if (l.y === y && l.x === x) {\r\n        return layout;\r\n    }\r\n    log(`Moving element ${l.id} to [${String(x)},${String(y)}] from [${l.x},${l.y}]`);\r\n    const oldX = l.x;\r\n    const oldY = l.y;\r\n    // This is quite a bit faster than extending the object\r\n    if (typeof x === 'number') {\r\n        l.x = x;\r\n    }\r\n    if (typeof y === 'number') {\r\n        l.y = y;\r\n    }\r\n    l.moved = true;\r\n    // If this collides with anything, move it.\r\n    // When doing this comparison, we have to sort the items we compare with\r\n    // to ensure, in the case of multiple collisions, that we're getting the\r\n    // nearest collision.\r\n    let sorted = sortLayoutItems(layout, compactType);\r\n    const movingUp = compactType === 'vertical' && typeof y === 'number'\r\n        ? oldY >= y\r\n        : compactType === 'horizontal' && typeof x === 'number'\r\n            ? oldX >= x\r\n            : false;\r\n    if (movingUp) {\r\n        sorted = sorted.reverse();\r\n    }\r\n    const collisions = getAllCollisions(sorted, l);\r\n    // There was a collision; abort\r\n    if (preventCollision && collisions.length) {\r\n        log(`Collision prevented on ${l.id}, reverting.`);\r\n        l.x = oldX;\r\n        l.y = oldY;\r\n        l.moved = false;\r\n        return layout;\r\n    }\r\n    // Move each item that collides away from this element.\r\n    for (let i = 0, len = collisions.length; i < len; i++) {\r\n        const collision = collisions[i];\r\n        log(`Resolving collision between ${l.id} at [${l.x},${l.y}] and ${collision.id} at [${collision.x},${collision.y}]`);\r\n        // Short circuit so we can't infinite loop\r\n        if (collision.moved) {\r\n            continue;\r\n        }\r\n        // Don't move static items - we have to move *this* element away\r\n        if (collision.static) {\r\n            layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\r\n        }\r\n        else {\r\n            layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\r\n        }\r\n    }\r\n    return layout;\r\n}\r\n/**\r\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\r\n * We attempt to move it up if there's room, otherwise it goes below.\r\n *\r\n * @param  {Array} layout            Full layout to modify.\r\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\r\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\r\n */\r\nfunction moveElementAwayFromCollision(layout, collidesWith, itemToMove, isUserAction, compactType, cols) {\r\n    const compactH = compactType === 'horizontal';\r\n    // Compact vertically if not set to horizontal\r\n    const compactV = compactType !== 'horizontal';\r\n    const preventCollision = collidesWith.static; // we're already colliding (not for static items)\r\n    // If there is enough space above the collision to put this element, move it there.\r\n    // We only do this on the main collision as this can get funky in cascades and cause\r\n    // unwanted swapping behavior.\r\n    if (isUserAction) {\r\n        // Reset isUserAction flag because we're not in the main collision anymore.\r\n        isUserAction = false;\r\n        // Make a mock item so we don't modify the item here, only modify in moveElement.\r\n        const fakeItem = {\r\n            x: compactH\r\n                ? Math.max(collidesWith.x - itemToMove.w, 0)\r\n                : itemToMove.x,\r\n            y: compactV\r\n                ? Math.max(collidesWith.y - itemToMove.h, 0)\r\n                : itemToMove.y,\r\n            w: itemToMove.w,\r\n            h: itemToMove.h,\r\n            id: '-1',\r\n        };\r\n        // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\r\n        if (!getFirstCollision(layout, fakeItem)) {\r\n            log(`Doing reverse collision on ${itemToMove.id} up to [${fakeItem.x},${fakeItem.y}].`);\r\n            return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\r\n        }\r\n    }\r\n    return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\r\n}\r\n/**\r\n * Helper to convert a number to a percentage string.\r\n *\r\n * @param  {Number} num Any number\r\n * @return {String}     That number as a percentage.\r\n */\r\nfunction perc(num) {\r\n    return num * 100 + '%';\r\n}\r\nfunction setTransform({ top, left, width, height }) {\r\n    // Replace unitless items with px\r\n    const translate = `translate(${left}px,${top}px)`;\r\n    return {\r\n        transform: translate,\r\n        WebkitTransform: translate,\r\n        MozTransform: translate,\r\n        msTransform: translate,\r\n        OTransform: translate,\r\n        width: `${width}px`,\r\n        height: `${height}px`,\r\n        position: 'absolute',\r\n    };\r\n}\r\nfunction setTopLeft({ top, left, width, height }) {\r\n    return {\r\n        top: `${top}px`,\r\n        left: `${left}px`,\r\n        width: `${width}px`,\r\n        height: `${height}px`,\r\n        position: 'absolute',\r\n    };\r\n}\r\n/**\r\n * Get layout items sorted from top left to right and down.\r\n *\r\n * @return {Array} Array of layout objects.\r\n * @return {Array}        Layout, sorted static items first.\r\n */\r\nfunction sortLayoutItems(layout, compactType) {\r\n    if (compactType === 'horizontal') {\r\n        return sortLayoutItemsByColRow(layout);\r\n    }\r\n    else {\r\n        return sortLayoutItemsByRowCol(layout);\r\n    }\r\n}\r\nfunction sortLayoutItemsByRowCol(layout) {\r\n    return [].concat(layout).sort(function (a, b) {\r\n        if (a.y > b.y || (a.y === b.y && a.x > b.x)) {\r\n            return 1;\r\n        }\r\n        else if (a.y === b.y && a.x === b.x) {\r\n            // Without this, we can get different sort results in IE vs. Chrome/FF\r\n            return 0;\r\n        }\r\n        return -1;\r\n    });\r\n}\r\nfunction sortLayoutItemsByColRow(layout) {\r\n    return [].concat(layout).sort(function (a, b) {\r\n        if (a.x > b.x || (a.x === b.x && a.y > b.y)) {\r\n            return 1;\r\n        }\r\n        return -1;\r\n    });\r\n}\r\n/**\r\n * Validate a layout. Throws errors.\r\n *\r\n * @param  {Array}  layout        Array of layout items.\r\n * @param  {String} [contextName] Context name for errors.\r\n * @throw  {Error}                Validation error.\r\n */\r\nfunction validateLayout(layout, contextName = 'Layout') {\r\n    const subProps = ['x', 'y', 'w', 'h'];\r\n    if (!Array.isArray(layout)) {\r\n        throw new Error(contextName + ' must be an array!');\r\n    }\r\n    for (let i = 0, len = layout.length; i < len; i++) {\r\n        const item = layout[i];\r\n        for (let j = 0; j < subProps.length; j++) {\r\n            if (typeof item[subProps[j]] !== 'number') {\r\n                throw new Error('ReactGridLayout: ' +\r\n                    contextName +\r\n                    '[' +\r\n                    i +\r\n                    '].' +\r\n                    subProps[j] +\r\n                    ' must be a number!');\r\n            }\r\n        }\r\n        if (item.id && typeof item.id !== 'string') {\r\n            throw new Error('ReactGridLayout: ' +\r\n                contextName +\r\n                '[' +\r\n                i +\r\n                '].i must be a string!');\r\n        }\r\n        if (item.static !== undefined && typeof item.static !== 'boolean') {\r\n            throw new Error('ReactGridLayout: ' +\r\n                contextName +\r\n                '[' +\r\n                i +\r\n                '].static must be a boolean!');\r\n        }\r\n    }\r\n}\r\n// Flow can't really figure this out, so we just use Object\r\nfunction autoBindHandlers(el, fns) {\r\n    fns.forEach(key => (el[key] = el[key].bind(el)));\r\n}\r\nfunction log(...args) {\r\n    if (!DEBUG) {\r\n        return;\r\n    }\r\n    // eslint-disable-next-line no-console\r\n    console.log(...args);\r\n}\r\nconst noop = () => { };\n\n/** Cached result of whether the user's browser supports passive event listeners. */\r\nlet supportsPassiveEvents;\r\n/**\r\n * Checks whether the user's browser supports passive event listeners.\r\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\r\n */\r\nfunction ktdSupportsPassiveEventListeners() {\r\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\r\n        try {\r\n            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\r\n                get: () => supportsPassiveEvents = true\r\n            }));\r\n        }\r\n        finally {\r\n            supportsPassiveEvents = supportsPassiveEvents || false;\r\n        }\r\n    }\r\n    return supportsPassiveEvents;\r\n}\r\n/**\r\n * Normalizes an `AddEventListener` object to something that can be passed\r\n * to `addEventListener` on any browser, no matter whether it supports the\r\n * `options` parameter.\r\n * @param options Object to be normalized.\r\n */\r\nfunction ktdNormalizePassiveListenerOptions(options) {\r\n    return ktdSupportsPassiveEventListeners() ? options : !!options.capture;\r\n}\n\n/** Options that can be used to bind a passive event listener. */\r\nconst passiveEventListenerOptions = ktdNormalizePassiveListenerOptions({ passive: true });\r\n/** Options that can be used to bind an active event listener. */\r\nconst activeEventListenerOptions = ktdNormalizePassiveListenerOptions({ passive: false });\r\nlet isMobile = null;\r\nfunction ktdIsMobileOrTablet() {\r\n    if (isMobile != null) {\r\n        return isMobile;\r\n    }\r\n    // Generic match pattern to identify mobile or tablet devices\r\n    const isMobileDevice = /Android|webOS|BlackBerry|Windows Phone|iPad|iPhone|iPod/i.test(navigator.userAgent);\r\n    // Since IOS 13 is not safe to just check for the generic solution. See: https://stackoverflow.com/questions/58019463/how-to-detect-device-name-in-safari-on-ios-13-while-it-doesnt-show-the-correct\r\n    const isIOSMobileDevice = /iPad|iPhone|iPod/.test(navigator.platform) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);\r\n    isMobile = isMobileDevice || isIOSMobileDevice;\r\n    return isMobile;\r\n}\r\nfunction ktdIsMouseEvent(event) {\r\n    return event.clientX != null;\r\n}\r\nfunction ktdIsTouchEvent(event) {\r\n    return event.touches != null && event.touches.length != null;\r\n}\r\nfunction ktdPointerClientX(event) {\r\n    return ktdIsMouseEvent(event) ? event.clientX : event.touches[0].clientX;\r\n}\r\nfunction ktdPointerClientY(event) {\r\n    return ktdIsMouseEvent(event) ? event.clientY : event.touches[0].clientY;\r\n}\r\nfunction ktdPointerClient(event) {\r\n    return {\r\n        clientX: ktdIsMouseEvent(event) ? event.clientX : event.touches[0].clientX,\r\n        clientY: ktdIsMouseEvent(event) ? event.clientY : event.touches[0].clientY\r\n    };\r\n}\r\n/**\r\n * Emits when a mousedown or touchstart emits. Avoids conflicts between both events.\r\n * @param element, html element where to  listen the events.\r\n * @param touchNumber number of the touch to track the event, default to the first one.\r\n */\r\nfunction ktdMouseOrTouchDown(element, touchNumber = 1) {\r\n    return iif(() => ktdIsMobileOrTablet(), fromEvent(element, 'touchstart', passiveEventListenerOptions).pipe(filter((touchEvent) => touchEvent.touches.length === touchNumber)), fromEvent(element, 'mousedown', activeEventListenerOptions).pipe(filter((mouseEvent) => {\r\n        /**\r\n         * 0 : Left mouse button\r\n         * 1 : Wheel button or middle button (if present)\r\n         * 2 : Right mouse button\r\n         */\r\n        return mouseEvent.button === 0; // Mouse down to be only fired if is left click\r\n    })));\r\n}\r\n/**\r\n * Emits when a 'mousemove' or a 'touchmove' event gets fired.\r\n * @param element, html element where to  listen the events.\r\n * @param touchNumber number of the touch to track the event, default to the first one.\r\n */\r\nfunction ktdMouseOrTouchMove(element, touchNumber = 1) {\r\n    return iif(() => ktdIsMobileOrTablet(), fromEvent(element, 'touchmove', activeEventListenerOptions).pipe(filter((touchEvent) => touchEvent.touches.length === touchNumber)), fromEvent(element, 'mousemove', activeEventListenerOptions));\r\n}\r\nfunction ktdTouchEnd(element, touchNumber = 1) {\r\n    return merge(fromEvent(element, 'touchend').pipe(filter((touchEvent) => touchEvent.touches.length === touchNumber - 1)), fromEvent(element, 'touchcancel').pipe(filter((touchEvent) => touchEvent.touches.length === touchNumber - 1)));\r\n}\r\n/**\r\n * Emits when a there is a 'mouseup' or the touch ends.\r\n * @param element, html element where to  listen the events.\r\n * @param touchNumber number of the touch to track the event, default to the first one.\r\n */\r\nfunction ktdMouseOrTouchEnd(element, touchNumber = 1) {\r\n    return iif(() => ktdIsMobileOrTablet(), ktdTouchEnd(element, touchNumber), fromEvent(element, 'mouseup'));\r\n}\n\n/** Tracks items by id. This function is mean to be used in conjunction with the ngFor that renders the 'ktd-grid-items' */\r\nfunction ktdTrackById(index, item) {\r\n    return item.id;\r\n}\r\n/**\r\n * Call react-grid-layout utils 'compact()' function and return the compacted layout.\r\n * @param layout to be compacted.\r\n * @param compactType, type of compaction.\r\n * @param cols, number of columns of the grid.\r\n */\r\nfunction ktdGridCompact(layout, compactType, cols) {\r\n    return compact(layout, compactType, cols)\r\n        // Prune react-grid-layout compact extra properties.\r\n        .map(item => ({ id: item.id, x: item.x, y: item.y, w: item.w, h: item.h, minW: item.minW, minH: item.minH, maxW: item.maxW, maxH: item.maxH }));\r\n}\r\nfunction screenXPosToGridValue(screenXPos, cols, width) {\r\n    return Math.round((screenXPos * cols) / width);\r\n}\r\nfunction screenYPosToGridValue(screenYPos, rowHeight, height) {\r\n    return Math.round(screenYPos / rowHeight);\r\n}\r\n/** Returns a Dictionary where the key is the id and the value is the change applied to that item. If no changes Dictionary is empty. */\r\nfunction ktdGetGridLayoutDiff(gridLayoutA, gridLayoutB) {\r\n    const diff = {};\r\n    gridLayoutA.forEach(itemA => {\r\n        const itemB = gridLayoutB.find(_itemB => _itemB.id === itemA.id);\r\n        if (itemB != null) {\r\n            const posChanged = itemA.x !== itemB.x || itemA.y !== itemB.y;\r\n            const sizeChanged = itemA.w !== itemB.w || itemA.h !== itemB.h;\r\n            const change = posChanged && sizeChanged ? 'moveresize' : posChanged ? 'move' : sizeChanged ? 'resize' : null;\r\n            if (change) {\r\n                diff[itemB.id] = { change };\r\n            }\r\n        }\r\n    });\r\n    return diff;\r\n}\r\n/**\r\n * Given the grid config & layout data and the current drag position & information, returns the corresponding layout and drag item position\r\n * @param gridItem grid item that is been dragged\r\n * @param config current grid configuration\r\n * @param compactionType type of compaction that will be performed\r\n * @param draggingData contains all the information about the drag\r\n */\r\nfunction ktdGridItemDragging(gridItem, config, compactionType, draggingData) {\r\n    const { pointerDownEvent, pointerDragEvent, gridElemClientRect, dragElemClientRect, scrollDifference } = draggingData;\r\n    const gridItemId = gridItem.id;\r\n    const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId);\r\n    const clientStartX = ktdPointerClientX(pointerDownEvent);\r\n    const clientStartY = ktdPointerClientY(pointerDownEvent);\r\n    const clientX = ktdPointerClientX(pointerDragEvent);\r\n    const clientY = ktdPointerClientY(pointerDragEvent);\r\n    const offsetX = clientStartX - dragElemClientRect.left;\r\n    const offsetY = clientStartY - dragElemClientRect.top;\r\n    // Grid element positions taking into account the possible scroll total difference from the beginning.\r\n    const gridElementLeftPosition = gridElemClientRect.left + scrollDifference.left;\r\n    const gridElementTopPosition = gridElemClientRect.top + scrollDifference.top;\r\n    // Calculate position relative to the grid element.\r\n    const gridRelXPos = clientX - gridElementLeftPosition - offsetX;\r\n    const gridRelYPos = clientY - gridElementTopPosition - offsetY;\r\n    // Get layout item position\r\n    const layoutItem = Object.assign(Object.assign({}, draggingElemPrevItem), { x: screenXPosToGridValue(gridRelXPos, config.cols, gridElemClientRect.width), y: screenYPosToGridValue(gridRelYPos, config.rowHeight, gridElemClientRect.height) });\r\n    // Correct the values if they overflow, since 'moveElement' function doesn't do it\r\n    layoutItem.x = Math.max(0, layoutItem.x);\r\n    layoutItem.y = Math.max(0, layoutItem.y);\r\n    if (layoutItem.x + layoutItem.w > config.cols) {\r\n        layoutItem.x = Math.max(0, config.cols - layoutItem.w);\r\n    }\r\n    // Parse to LayoutItem array data in order to use 'react.grid-layout' utils\r\n    const layoutItems = config.layout;\r\n    const draggedLayoutItem = layoutItems.find(item => item.id === gridItemId);\r\n    let newLayoutItems = moveElement(layoutItems, draggedLayoutItem, layoutItem.x, layoutItem.y, true, config.preventCollision, compactionType, config.cols);\r\n    newLayoutItems = compact(newLayoutItems, compactionType, config.cols);\r\n    return {\r\n        layout: newLayoutItems,\r\n        draggedItemPos: {\r\n            top: gridRelYPos,\r\n            left: gridRelXPos,\r\n            width: dragElemClientRect.width,\r\n            height: dragElemClientRect.height,\r\n        }\r\n    };\r\n}\r\n/**\r\n * Given the grid config & layout data and the current drag position & information, returns the corresponding layout and drag item position\r\n * @param gridItem grid item that is been dragged\r\n * @param config current grid configuration\r\n * @param compactionType type of compaction that will be performed\r\n * @param draggingData contains all the information about the drag\r\n */\r\nfunction ktdGridItemResizing(gridItem, config, compactionType, draggingData) {\r\n    var _a, _b, _c, _d;\r\n    const { pointerDownEvent, pointerDragEvent, gridElemClientRect, dragElemClientRect, scrollDifference } = draggingData;\r\n    const gridItemId = gridItem.id;\r\n    const clientStartX = ktdPointerClientX(pointerDownEvent);\r\n    const clientStartY = ktdPointerClientY(pointerDownEvent);\r\n    const clientX = ktdPointerClientX(pointerDragEvent);\r\n    const clientY = ktdPointerClientY(pointerDragEvent);\r\n    // Get the difference between the mouseDown and the position 'right' of the resize element.\r\n    const resizeElemOffsetX = dragElemClientRect.width - (clientStartX - dragElemClientRect.left);\r\n    const resizeElemOffsetY = dragElemClientRect.height - (clientStartY - dragElemClientRect.top);\r\n    const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId);\r\n    const width = clientX + resizeElemOffsetX - (dragElemClientRect.left + scrollDifference.left);\r\n    const height = clientY + resizeElemOffsetY - (dragElemClientRect.top + scrollDifference.top);\r\n    // Get layout item grid position\r\n    const layoutItem = Object.assign(Object.assign({}, draggingElemPrevItem), { w: screenXPosToGridValue(width, config.cols, gridElemClientRect.width), h: screenYPosToGridValue(height, config.rowHeight, gridElemClientRect.height) });\r\n    layoutItem.w = limitNumberWithinRange(layoutItem.w, (_a = gridItem.minW) !== null && _a !== void 0 ? _a : layoutItem.minW, (_b = gridItem.maxW) !== null && _b !== void 0 ? _b : layoutItem.maxW);\r\n    layoutItem.h = limitNumberWithinRange(layoutItem.h, (_c = gridItem.minH) !== null && _c !== void 0 ? _c : layoutItem.minH, (_d = gridItem.maxH) !== null && _d !== void 0 ? _d : layoutItem.maxH);\r\n    if (layoutItem.x + layoutItem.w > config.cols) {\r\n        layoutItem.w = Math.max(1, config.cols - layoutItem.x);\r\n    }\r\n    if (config.preventCollision) {\r\n        const maxW = layoutItem.w;\r\n        const maxH = layoutItem.h;\r\n        let colliding = hasCollision(config.layout, layoutItem);\r\n        let shrunkDimension;\r\n        while (colliding) {\r\n            shrunkDimension = getDimensionToShrink(layoutItem, shrunkDimension);\r\n            layoutItem[shrunkDimension]--;\r\n            colliding = hasCollision(config.layout, layoutItem);\r\n        }\r\n        if (shrunkDimension === 'w') {\r\n            layoutItem.h = maxH;\r\n            colliding = hasCollision(config.layout, layoutItem);\r\n            while (colliding) {\r\n                layoutItem.h--;\r\n                colliding = hasCollision(config.layout, layoutItem);\r\n            }\r\n        }\r\n        if (shrunkDimension === 'h') {\r\n            layoutItem.w = maxW;\r\n            colliding = hasCollision(config.layout, layoutItem);\r\n            while (colliding) {\r\n                layoutItem.w--;\r\n                colliding = hasCollision(config.layout, layoutItem);\r\n            }\r\n        }\r\n    }\r\n    const newLayoutItems = config.layout.map((item) => {\r\n        return item.id === gridItemId ? layoutItem : item;\r\n    });\r\n    return {\r\n        layout: compact(newLayoutItems, compactionType, config.cols),\r\n        draggedItemPos: {\r\n            top: dragElemClientRect.top - gridElemClientRect.top,\r\n            left: dragElemClientRect.left - gridElemClientRect.left,\r\n            width,\r\n            height,\r\n        }\r\n    };\r\n}\r\nfunction hasCollision(layout, layoutItem) {\r\n    return !!getFirstCollision(layout, layoutItem);\r\n}\r\nfunction getDimensionToShrink(layoutItem, lastShrunk) {\r\n    if (layoutItem.h <= 1) {\r\n        return 'w';\r\n    }\r\n    if (layoutItem.w <= 1) {\r\n        return 'h';\r\n    }\r\n    return lastShrunk === 'w' ? 'h' : 'w';\r\n}\r\n/**\r\n * Given the current number and min/max values, returns the number within the range\r\n * @param number can be any numeric value\r\n * @param min minimum value of range\r\n * @param max maximum value of range\r\n */\r\nfunction limitNumberWithinRange(num, min = 1, max = Infinity) {\r\n    return Math.min(Math.max(num, min < 1 ? 1 : min), max);\r\n}\n\n/**\r\n * Injection token that can be used to reference instances of `KtdGridDragHandle`. It serves as\r\n * alternative token to the actual `KtdGridDragHandle` class which could cause unnecessary\r\n * retention of the class and its directive metadata.\r\n */\r\nconst KTD_GRID_DRAG_HANDLE = new InjectionToken('KtdGridDragHandle');\r\n/** Handle that can be used to drag a KtdGridItem instance. */\r\n// tslint:disable-next-line:directive-class-suffix\r\nclass KtdGridDragHandle {\r\n    constructor(element) {\r\n        this.element = element;\r\n    }\r\n}\r\nKtdGridDragHandle.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.14\", ngImport: i0, type: KtdGridDragHandle, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });\r\nKtdGridDragHandle.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"12.2.14\", type: KtdGridDragHandle, selector: \"[ktdGridDragHandle]\", host: { classAttribute: \"ktd-grid-drag-handle\" }, providers: [{ provide: KTD_GRID_DRAG_HANDLE, useExisting: KtdGridDragHandle }], ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.14\", ngImport: i0, type: KtdGridDragHandle, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[ktdGridDragHandle]',\r\n                    host: {\r\n                        class: 'ktd-grid-drag-handle'\r\n                    },\r\n                    providers: [{ provide: KTD_GRID_DRAG_HANDLE, useExisting: KtdGridDragHandle }],\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });\n\n/**\r\n * Injection token that can be used to reference instances of `KtdGridResizeHandle`. It serves as\r\n * alternative token to the actual `KtdGridResizeHandle` class which could cause unnecessary\r\n * retention of the class and its directive metadata.\r\n */\r\nconst KTD_GRID_RESIZE_HANDLE = new InjectionToken('KtdGridResizeHandle');\r\n/** Handle that can be used to drag a KtdGridItem instance. */\r\nclass KtdGridResizeHandle {\r\n    constructor(element) {\r\n        this.element = element;\r\n    }\r\n}\r\nKtdGridResizeHandle.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.14\", ngImport: i0, type: KtdGridResizeHandle, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });\r\nKtdGridResizeHandle.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"12.2.14\", type: KtdGridResizeHandle, selector: \"[ktdGridResizeHandle]\", host: { classAttribute: \"ktd-grid-resize-handle\" }, providers: [{ provide: KTD_GRID_RESIZE_HANDLE, useExisting: KtdGridResizeHandle }], ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.14\", ngImport: i0, type: KtdGridResizeHandle, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[ktdGridResizeHandle]',\r\n                    host: {\r\n                        class: 'ktd-grid-resize-handle'\r\n                    },\r\n                    providers: [{ provide: KTD_GRID_RESIZE_HANDLE, useExisting: KtdGridResizeHandle }],\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });\n\nconst GRID_ITEM_GET_RENDER_DATA_TOKEN = new InjectionToken('GRID_ITEM_GET_RENDER_DATA_TOKEN');\n\n/** Runs source observable outside the zone */\r\nfunction ktdOutsideZone(zone) {\r\n    return (source) => {\r\n        return new Observable(observer => {\r\n            return zone.runOutsideAngular(() => source.subscribe(observer));\r\n        });\r\n    };\r\n}\r\n/** Rxjs operator that makes source observable to no emit any data */\r\nfunction ktdNoEmit() {\r\n    return (source$) => {\r\n        return source$.pipe(filter(() => false));\r\n    };\r\n}\n\n/** Coerces a data-bound value (typically a string) to a boolean. */\r\nfunction coerceBooleanProperty(value) {\r\n    return value != null && `${value}` !== 'false';\r\n}\n\nfunction coerceNumberProperty(value, fallbackValue = 0) {\r\n    return _isNumberValue(value) ? Number(value) : fallbackValue;\r\n}\r\n/**\r\n * Whether the provided value is considered a number.\r\n * @docs-private\r\n */\r\nfunction _isNumberValue(value) {\r\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\r\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\r\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\r\n    return !isNaN(parseFloat(value)) && !isNaN(Number(value));\r\n}\n\n/** Event options that can be used to bind an active, capturing event. */\r\nconst activeCapturingEventOptions = ktdNormalizePassiveListenerOptions({\r\n    passive: false,\r\n    capture: true\r\n});\r\nclass KtdGridService {\r\n    constructor(ngZone) {\r\n        this.ngZone = ngZone;\r\n        this.touchMoveSubject = new Subject();\r\n        this.touchMove$ = this.touchMoveSubject.asObservable();\r\n        this.registerTouchMoveSubscription();\r\n    }\r\n    ngOnDestroy() {\r\n        this.touchMoveSubscription.unsubscribe();\r\n    }\r\n    mouseOrTouchMove$(element) {\r\n        return iif(() => ktdIsMobileOrTablet(), this.touchMove$, fromEvent(element, 'mousemove', activeCapturingEventOptions) // TODO: Fix rxjs typings, boolean should be a good param too.\r\n        );\r\n    }\r\n    registerTouchMoveSubscription() {\r\n        // The `touchmove` event gets bound once, ahead of time, because WebKit\r\n        // won't preventDefault on a dynamically-added `touchmove` listener.\r\n        // See https://bugs.webkit.org/show_bug.cgi?id=184250.\r\n        this.touchMoveSubscription = this.ngZone.runOutsideAngular(() => \r\n        // The event handler has to be explicitly active,\r\n        // because newer browsers make it passive by default.\r\n        fromEvent(document, 'touchmove', activeCapturingEventOptions) // TODO: Fix rxjs typings, boolean should be a good param too.\r\n            .pipe(filter((touchEvent) => touchEvent.touches.length === 1))\r\n            .subscribe((touchEvent) => this.touchMoveSubject.next(touchEvent)));\r\n    }\r\n}\r\nKtdGridService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.14\", ngImport: i0, type: KtdGridService, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });\r\nKtdGridService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.14\", ngImport: i0, type: KtdGridService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.14\", ngImport: i0, type: KtdGridService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });\n\nclass KtdGridItemComponent {\r\n    constructor(elementRef, gridService, renderer, ngZone, getItemRenderData) {\r\n        this.elementRef = elementRef;\r\n        this.gridService = gridService;\r\n        this.renderer = renderer;\r\n        this.ngZone = ngZone;\r\n        this.getItemRenderData = getItemRenderData;\r\n        /** CSS transition style. Note that for more performance is preferable only make transition on transform property. */\r\n        this.transition = 'transform 500ms ease, width 500ms ease, height 500ms ease';\r\n        this._dragStartThreshold = 0;\r\n        this._draggable = true;\r\n        this._draggable$ = new BehaviorSubject(this._draggable);\r\n        this._resizable = true;\r\n        this._resizable$ = new BehaviorSubject(this._resizable);\r\n        this.dragStartSubject = new Subject();\r\n        this.resizeStartSubject = new Subject();\r\n        this.subscriptions = [];\r\n        this.dragStart$ = this.dragStartSubject.asObservable();\r\n        this.resizeStart$ = this.resizeStartSubject.asObservable();\r\n    }\r\n    /** Id of the grid item. This property is strictly compulsory. */\r\n    get id() {\r\n        return this._id;\r\n    }\r\n    set id(val) {\r\n        this._id = val;\r\n    }\r\n    /** Minimum amount of pixels that the user should move before it starts the drag sequence. */\r\n    get dragStartThreshold() { return this._dragStartThreshold; }\r\n    set dragStartThreshold(val) {\r\n        this._dragStartThreshold = coerceNumberProperty(val);\r\n    }\r\n    /** Whether the item is draggable or not. Defaults to true. */\r\n    get draggable() {\r\n        return this._draggable;\r\n    }\r\n    set draggable(val) {\r\n        this._draggable = coerceBooleanProperty(val);\r\n        this._draggable$.next(this._draggable);\r\n    }\r\n    /** Whether the item is resizable or not. Defaults to true. */\r\n    get resizable() {\r\n        return this._resizable;\r\n    }\r\n    set resizable(val) {\r\n        this._resizable = coerceBooleanProperty(val);\r\n        this._resizable$.next(this._resizable);\r\n    }\r\n    ngOnInit() {\r\n        const gridItemRenderData = this.getItemRenderData(this.id);\r\n        this.setStyles(gridItemRenderData);\r\n    }\r\n    ngAfterContentInit() {\r\n        this.subscriptions.push(this._dragStart$().subscribe(this.dragStartSubject), this._resizeStart$().subscribe(this.resizeStartSubject));\r\n    }\r\n    ngOnDestroy() {\r\n        this.subscriptions.forEach(sub => sub.unsubscribe());\r\n    }\r\n    setStyles({ top, left, width, height }) {\r\n        // transform is 6x times faster than top/left\r\n        this.renderer.setStyle(this.elementRef.nativeElement, 'transform', `translateX(${left}) translateY(${top})`);\r\n        this.renderer.setStyle(this.elementRef.nativeElement, 'display', `block`);\r\n        this.renderer.setStyle(this.elementRef.nativeElement, 'transition', this.transition);\r\n        if (width != null) {\r\n            this.renderer.setStyle(this.elementRef.nativeElement, 'width', width);\r\n        }\r\n        if (height != null) {\r\n            this.renderer.setStyle(this.elementRef.nativeElement, 'height', height);\r\n        }\r\n    }\r\n    _dragStart$() {\r\n        return this._draggable$.pipe(switchMap((draggable) => {\r\n            if (!draggable) {\r\n                return NEVER;\r\n            }\r\n            else {\r\n                return this._dragHandles.changes.pipe(startWith(this._dragHandles), switchMap((dragHandles) => {\r\n                    return iif(() => dragHandles.length > 0, merge(...dragHandles.toArray().map(dragHandle => ktdMouseOrTouchDown(dragHandle.element.nativeElement, 1))), ktdMouseOrTouchDown(this.elementRef.nativeElement, 1)).pipe(exhaustMap((startEvent) => {\r\n                        // If the event started from an element with the native HTML drag&drop, it'll interfere\r\n                        // with our own dragging (e.g. `img` tags do it by default). Prevent the default action\r\n                        // to stop it from happening. Note that preventing on `dragstart` also seems to work, but\r\n                        // it's flaky and it fails if the user drags it away quickly. Also note that we only want\r\n                        // to do this for `mousedown` since doing the same for `touchstart` will stop any `click`\r\n                        // events from firing on touch devices.\r\n                        if (startEvent.target && startEvent.target.draggable && startEvent.type === 'mousedown') {\r\n                            startEvent.preventDefault();\r\n                        }\r\n                        const startPointer = ktdPointerClient(startEvent);\r\n                        return this.gridService.mouseOrTouchMove$(document).pipe(takeUntil(ktdMouseOrTouchEnd(document, 1)), ktdOutsideZone(this.ngZone), filter((moveEvent) => {\r\n                            moveEvent.preventDefault();\r\n                            const movePointer = ktdPointerClient(moveEvent);\r\n                            const distanceX = Math.abs(startPointer.clientX - movePointer.clientX);\r\n                            const distanceY = Math.abs(startPointer.clientY - movePointer.clientY);\r\n                            // When this conditions returns true mean that we are over threshold.\r\n                            return distanceX + distanceY >= this.dragStartThreshold;\r\n                        }), take(1), \r\n                        // Return the original start event\r\n                        map(() => startEvent));\r\n                    }));\r\n                }));\r\n            }\r\n        }));\r\n    }\r\n    _resizeStart$() {\r\n        return this._resizable$.pipe(switchMap((resizable) => {\r\n            if (!resizable) {\r\n                // Side effect to hide the resizeElem if resize is disabled.\r\n                this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'none');\r\n                return NEVER;\r\n            }\r\n            else {\r\n                return this._resizeHandles.changes.pipe(startWith(this._resizeHandles), switchMap((resizeHandles) => {\r\n                    if (resizeHandles.length > 0) {\r\n                        // Side effect to hide the resizeElem if there are resize handles.\r\n                        this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'none');\r\n                        return merge(...resizeHandles.toArray().map(resizeHandle => ktdMouseOrTouchDown(resizeHandle.element.nativeElement, 1)));\r\n                    }\r\n                    else {\r\n                        this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'block');\r\n                        return ktdMouseOrTouchDown(this.resizeElem.nativeElement, 1);\r\n                    }\r\n                }));\r\n            }\r\n        }));\r\n    }\r\n}\r\nKtdGridItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.14\", ngImport: i0, type: KtdGridItemComponent, deps: [{ token: i0.ElementRef }, { token: KtdGridService }, { token: i0.Renderer2 }, { token: i0.NgZone }, { token: GRID_ITEM_GET_RENDER_DATA_TOKEN }], target: i0.ɵɵFactoryTarget.Component });\r\nKtdGridItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"12.2.14\", type: KtdGridItemComponent, selector: \"ktd-grid-item\", inputs: { minW: \"minW\", minH: \"minH\", maxW: \"maxW\", maxH: \"maxH\", transition: \"transition\", id: \"id\", dragStartThreshold: \"dragStartThreshold\", draggable: \"draggable\", resizable: \"resizable\" }, queries: [{ propertyName: \"_dragHandles\", predicate: KTD_GRID_DRAG_HANDLE, descendants: true }, { propertyName: \"_resizeHandles\", predicate: KTD_GRID_RESIZE_HANDLE, descendants: true }], viewQueries: [{ propertyName: \"resizeElem\", first: true, predicate: [\"resizeElem\"], descendants: true, read: ElementRef, static: true }], ngImport: i0, template: \"<ng-content></ng-content>\\r\\n<div #resizeElem class=\\\"grid-item-resize-icon\\\"></div>\\r\\n\", styles: [\":host{display:none;position:absolute;z-index:1;overflow:hidden}:host div{position:absolute;-webkit-user-select:none;user-select:none;z-index:10}:host div.grid-item-resize-icon{cursor:se-resize;width:20px;height:20px;bottom:0;right:0;color:inherit}:host div.grid-item-resize-icon:after{content:\\\"\\\";position:absolute;right:3px;bottom:3px;width:5px;height:5px;border-right:2px solid;border-bottom:2px solid}.display-none{display:none!important}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.14\", ngImport: i0, type: KtdGridItemComponent, decorators: [{\r\n            type: Component,\r\n            args: [{\r\n                    selector: 'ktd-grid-item',\r\n                    templateUrl: './grid-item.component.html',\r\n                    styleUrls: ['./grid-item.component.scss'],\r\n                    changeDetection: ChangeDetectionStrategy.OnPush\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: KtdGridService }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [GRID_ITEM_GET_RENDER_DATA_TOKEN]\r\n                }] }]; }, propDecorators: { _dragHandles: [{\r\n                type: ContentChildren,\r\n                args: [KTD_GRID_DRAG_HANDLE, { descendants: true }]\r\n            }], _resizeHandles: [{\r\n                type: ContentChildren,\r\n                args: [KTD_GRID_RESIZE_HANDLE, { descendants: true }]\r\n            }], resizeElem: [{\r\n                type: ViewChild,\r\n                args: ['resizeElem', { static: true, read: ElementRef }]\r\n            }], minW: [{\r\n                type: Input\r\n            }], minH: [{\r\n                type: Input\r\n            }], maxW: [{\r\n                type: Input\r\n            }], maxH: [{\r\n                type: Input\r\n            }], transition: [{\r\n                type: Input\r\n            }], id: [{\r\n                type: Input\r\n            }], dragStartThreshold: [{\r\n                type: Input\r\n            }], draggable: [{\r\n                type: Input\r\n            }], resizable: [{\r\n                type: Input\r\n            }] } });\n\n// tslint:disable\r\n/**\r\n * Client rect utilities.\r\n * This file is taken from Angular Material repository. This is the reason why the tslint is disabled on this case.\r\n * Don't enable it until some custom change is done on this file.\r\n */\r\n/** Gets a mutable version of an element's bounding `ClientRect`. */\r\nfunction getMutableClientRect(element) {\r\n    const clientRect = element.getBoundingClientRect();\r\n    // We need to clone the `clientRect` here, because all the values on it are readonly\r\n    // and we need to be able to update them. Also we can't use a spread here, because\r\n    // the values on a `ClientRect` aren't own properties. See:\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\r\n    return {\r\n        top: clientRect.top,\r\n        right: clientRect.right,\r\n        bottom: clientRect.bottom,\r\n        left: clientRect.left,\r\n        width: clientRect.width,\r\n        height: clientRect.height\r\n    };\r\n}\r\n/**\r\n * Checks whether some coordinates are within a `ClientRect`.\r\n * @param clientRect ClientRect that is being checked.\r\n * @param x Coordinates along the X axis.\r\n * @param y Coordinates along the Y axis.\r\n */\r\nfunction isInsideClientRect(clientRect, x, y) {\r\n    const { top, bottom, left, right } = clientRect;\r\n    return y >= top && y <= bottom && x >= left && x <= right;\r\n}\r\n/**\r\n * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\r\n * @param clientRect `ClientRect` that should be updated.\r\n * @param top Amount to add to the `top` position.\r\n * @param left Amount to add to the `left` position.\r\n */\r\nfunction adjustClientRect(clientRect, top, left) {\r\n    clientRect.top += top;\r\n    clientRect.bottom = clientRect.top + clientRect.height;\r\n    clientRect.left += left;\r\n    clientRect.right = clientRect.left + clientRect.width;\r\n}\r\n/**\r\n * Checks whether the pointer coordinates are close to a ClientRect.\r\n * @param rect ClientRect to check against.\r\n * @param threshold Threshold around the ClientRect.\r\n * @param pointerX Coordinates along the X axis.\r\n * @param pointerY Coordinates along the Y axis.\r\n */\r\nfunction isPointerNearClientRect(rect, threshold, pointerX, pointerY) {\r\n    const { top, right, bottom, left, width, height } = rect;\r\n    const xThreshold = width * threshold;\r\n    const yThreshold = height * threshold;\r\n    return pointerY > top - yThreshold && pointerY < bottom + yThreshold &&\r\n        pointerX > left - xThreshold && pointerX < right + xThreshold;\r\n}\n\n/**\r\n * Proximity, as a ratio to width/height at which to start auto-scrolling.\r\n * The value comes from trying it out manually until it feels right.\r\n */\r\nconst SCROLL_PROXIMITY_THRESHOLD = 0.05;\r\n/**\r\n * Increments the vertical scroll position of a node.\r\n * @param node Node whose scroll position should change.\r\n * @param amount Amount of pixels that the `node` should be scrolled.\r\n */\r\nfunction incrementVerticalScroll(node, amount) {\r\n    if (node === window) {\r\n        node.scrollBy(0, amount);\r\n    }\r\n    else {\r\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\r\n        node.scrollTop += amount;\r\n    }\r\n}\r\n/**\r\n * Increments the horizontal scroll position of a node.\r\n * @param node Node whose scroll position should change.\r\n * @param amount Amount of pixels that the `node` should be scrolled.\r\n */\r\nfunction incrementHorizontalScroll(node, amount) {\r\n    if (node === window) {\r\n        node.scrollBy(amount, 0);\r\n    }\r\n    else {\r\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\r\n        node.scrollLeft += amount;\r\n    }\r\n}\r\n/**\r\n * Gets whether the vertical auto-scroll direction of a node.\r\n * @param clientRect Dimensions of the node.\r\n * @param pointerY Position of the user's pointer along the y axis.\r\n */\r\nfunction getVerticalScrollDirection(clientRect, pointerY) {\r\n    const { top, bottom, height } = clientRect;\r\n    const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;\r\n    if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {\r\n        return 1 /* UP */;\r\n    }\r\n    else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {\r\n        return 2 /* DOWN */;\r\n    }\r\n    return 0 /* NONE */;\r\n}\r\n/**\r\n * Gets whether the horizontal auto-scroll direction of a node.\r\n * @param clientRect Dimensions of the node.\r\n * @param pointerX Position of the user's pointer along the x axis.\r\n */\r\nfunction getHorizontalScrollDirection(clientRect, pointerX) {\r\n    const { left, right, width } = clientRect;\r\n    const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;\r\n    if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {\r\n        return 1 /* LEFT */;\r\n    }\r\n    else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {\r\n        return 2 /* RIGHT */;\r\n    }\r\n    return 0 /* NONE */;\r\n}\r\n/**\r\n * Returns an observable that schedules a loop and apply scroll on the scrollNode into the specified direction/s.\r\n * This observable doesn't emit, it just performs the 'scroll' side effect.\r\n * @param scrollNode, node where the scroll would be applied.\r\n * @param verticalScrollDirection, vertical direction of the scroll.\r\n * @param horizontalScrollDirection, horizontal direction of the scroll.\r\n * @param scrollStep, scroll step in CSS pixels that would be applied in every loop.\r\n */\r\nfunction scrollToDirectionInterval$(scrollNode, verticalScrollDirection, horizontalScrollDirection, scrollStep = 2) {\r\n    return interval(0, animationFrameScheduler)\r\n        .pipe(tap(() => {\r\n        if (verticalScrollDirection === 1 /* UP */) {\r\n            incrementVerticalScroll(scrollNode, -scrollStep);\r\n        }\r\n        else if (verticalScrollDirection === 2 /* DOWN */) {\r\n            incrementVerticalScroll(scrollNode, scrollStep);\r\n        }\r\n        if (horizontalScrollDirection === 1 /* LEFT */) {\r\n            incrementHorizontalScroll(scrollNode, -scrollStep);\r\n        }\r\n        else if (horizontalScrollDirection === 2 /* RIGHT */) {\r\n            incrementHorizontalScroll(scrollNode, scrollStep);\r\n        }\r\n    }), ktdNoEmit());\r\n}\r\n/**\r\n * Given a source$ observable with pointer location, scroll the scrollNode if the pointer is near to it.\r\n * This observable doesn't emit, it just performs a 'scroll' side effect.\r\n * @param scrollableParent, parent node in which the scroll would be performed.\r\n * @param options, configuration options.\r\n */\r\nfunction ktdScrollIfNearElementClientRect$(scrollableParent, options) {\r\n    let scrollNode;\r\n    let scrollableParentClientRect;\r\n    let scrollableParentScrollWidth;\r\n    if (scrollableParent === document) {\r\n        scrollNode = document.defaultView;\r\n        const { width, height } = getViewportSize();\r\n        scrollableParentClientRect = { width, height, top: 0, right: width, bottom: height, left: 0 };\r\n        scrollableParentScrollWidth = getDocumentScrollWidth();\r\n    }\r\n    else {\r\n        scrollNode = scrollableParent;\r\n        scrollableParentClientRect = getMutableClientRect(scrollableParent);\r\n        scrollableParentScrollWidth = scrollableParent.scrollWidth;\r\n    }\r\n    /**\r\n     * IMPORTANT: By design, only let scroll horizontal if the scrollable parent has explicitly an scroll horizontal.\r\n     * This layout solution is not designed in mind to have any scroll horizontal, but exceptionally we allow it in this\r\n     * specific use case.\r\n     */\r\n    options = options || {};\r\n    if (options.disableHorizontal == null && scrollableParentScrollWidth <= scrollableParentClientRect.width) {\r\n        options.disableHorizontal = true;\r\n    }\r\n    return (source$) => source$.pipe(map(({ pointerX, pointerY }) => {\r\n        let verticalScrollDirection = getVerticalScrollDirection(scrollableParentClientRect, pointerY);\r\n        let horizontalScrollDirection = getHorizontalScrollDirection(scrollableParentClientRect, pointerX);\r\n        // Check if scroll directions are disabled.\r\n        if (options === null || options === void 0 ? void 0 : options.disableVertical) {\r\n            verticalScrollDirection = 0 /* NONE */;\r\n        }\r\n        if (options === null || options === void 0 ? void 0 : options.disableHorizontal) {\r\n            horizontalScrollDirection = 0 /* NONE */;\r\n        }\r\n        return { verticalScrollDirection, horizontalScrollDirection };\r\n    }), distinctUntilChanged((prev, actual) => {\r\n        return prev.verticalScrollDirection === actual.verticalScrollDirection\r\n            && prev.horizontalScrollDirection === actual.horizontalScrollDirection;\r\n    }), switchMap(({ verticalScrollDirection, horizontalScrollDirection }) => {\r\n        if (verticalScrollDirection || horizontalScrollDirection) {\r\n            return scrollToDirectionInterval$(scrollNode, verticalScrollDirection, horizontalScrollDirection, options === null || options === void 0 ? void 0 : options.scrollStep);\r\n        }\r\n        else {\r\n            return NEVER;\r\n        }\r\n    }));\r\n}\r\n/**\r\n * Emits on EVERY scroll event and returns the accumulated scroll offset relative to the initial scroll position.\r\n * @param scrollableParent, node in which scroll events would be listened.\r\n */\r\nfunction ktdGetScrollTotalRelativeDifference$(scrollableParent) {\r\n    let scrollInitialPosition;\r\n    // Calculate initial scroll position\r\n    if (scrollableParent === document) {\r\n        scrollInitialPosition = getViewportScrollPosition();\r\n    }\r\n    else {\r\n        scrollInitialPosition = {\r\n            top: scrollableParent.scrollTop,\r\n            left: scrollableParent.scrollLeft\r\n        };\r\n    }\r\n    return fromEvent(scrollableParent, 'scroll', ktdNormalizePassiveListenerOptions({ capture: true })).pipe(map(() => {\r\n        let newTop;\r\n        let newLeft;\r\n        if (scrollableParent === document) {\r\n            const viewportScrollPosition = getViewportScrollPosition();\r\n            newTop = viewportScrollPosition.top;\r\n            newLeft = viewportScrollPosition.left;\r\n        }\r\n        else {\r\n            newTop = scrollableParent.scrollTop;\r\n            newLeft = scrollableParent.scrollLeft;\r\n        }\r\n        const topDifference = scrollInitialPosition.top - newTop;\r\n        const leftDifference = scrollInitialPosition.left - newLeft;\r\n        return { top: topDifference, left: leftDifference };\r\n    }));\r\n}\r\n/** Returns the viewport's width and height. */\r\nfunction getViewportSize() {\r\n    const _window = document.defaultView || window;\r\n    return {\r\n        width: _window.innerWidth,\r\n        height: _window.innerHeight\r\n    };\r\n}\r\n/** Gets a ClientRect for the viewport's bounds. */\r\nfunction getViewportRect() {\r\n    // Use the document element's bounding rect rather than the window scroll properties\r\n    // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\r\n    // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\r\n    // conceptual viewports. Under most circumstances these viewports are equivalent, but they\r\n    // can disagree when the page is pinch-zoomed (on devices that support touch).\r\n    // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\r\n    // We use the documentElement instead of the body because, by default (without a css reset)\r\n    // browsers typically give the document body an 8px margin, which is not included in\r\n    // getBoundingClientRect().\r\n    const scrollPosition = getViewportScrollPosition();\r\n    const { width, height } = getViewportSize();\r\n    return {\r\n        top: scrollPosition.top,\r\n        left: scrollPosition.left,\r\n        bottom: scrollPosition.top + height,\r\n        right: scrollPosition.left + width,\r\n        height,\r\n        width,\r\n    };\r\n}\r\n/** Gets the (top, left) scroll position of the viewport. */\r\nfunction getViewportScrollPosition() {\r\n    // The top-left-corner of the viewport is determined by the scroll position of the document\r\n    // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\r\n    // whether `document.body` or `document.documentElement` is the scrolled element, so reading\r\n    // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\r\n    // `document.documentElement` works consistently, where the `top` and `left` values will\r\n    // equal negative the scroll position.\r\n    const windowRef = document.defaultView || window;\r\n    const documentElement = document.documentElement;\r\n    const documentRect = documentElement.getBoundingClientRect();\r\n    const top = -documentRect.top || document.body.scrollTop || windowRef.scrollY ||\r\n        documentElement.scrollTop || 0;\r\n    const left = -documentRect.left || document.body.scrollLeft || windowRef.scrollX ||\r\n        documentElement.scrollLeft || 0;\r\n    return { top, left };\r\n}\r\n/** Returns the document scroll width */\r\nfunction getDocumentScrollWidth() {\r\n    return Math.max(document.body.scrollWidth, document.documentElement.scrollWidth);\r\n}\n\nfunction getDragResizeEventData(gridItem, layout) {\r\n    return {\r\n        layout,\r\n        layoutItem: layout.find((item) => item.id === gridItem.id),\r\n        gridItemRef: gridItem\r\n    };\r\n}\r\nfunction layoutToRenderItems(config, width, height) {\r\n    const { cols, rowHeight, layout } = config;\r\n    const renderItems = {};\r\n    for (const item of layout) {\r\n        renderItems[item.id] = {\r\n            id: item.id,\r\n            top: item.y === 0 ? 0 : item.y * rowHeight,\r\n            left: item.x * (width / cols),\r\n            width: item.w * (width / cols),\r\n            height: item.h * rowHeight\r\n        };\r\n    }\r\n    return renderItems;\r\n}\r\nfunction getGridHeight(layout, rowHeight) {\r\n    return layout.reduce((acc, cur) => Math.max(acc, (cur.y + cur.h) * rowHeight), 0);\r\n}\r\n// tslint:disable-next-line\r\nfunction parseRenderItemToPixels(renderItem) {\r\n    return {\r\n        id: renderItem.id,\r\n        top: `${renderItem.top}px`,\r\n        left: `${renderItem.left}px`,\r\n        width: `${renderItem.width}px`,\r\n        height: `${renderItem.height}px`\r\n    };\r\n}\r\n// tslint:disable-next-line:ktd-prefix-code\r\nfunction __gridItemGetRenderDataFactoryFunc(gridCmp) {\r\n    // tslint:disable-next-line:only-arrow-functions\r\n    return function (id) {\r\n        return parseRenderItemToPixels(gridCmp.getItemRenderData(id));\r\n    };\r\n}\r\nfunction ktdGridItemGetRenderDataFactoryFunc(gridCmp) {\r\n    // Workaround explained: https://github.com/ng-packagr/ng-packagr/issues/696#issuecomment-387114613\r\n    const resultFunc = __gridItemGetRenderDataFactoryFunc(gridCmp);\r\n    return resultFunc;\r\n}\r\nclass KtdGridComponent {\r\n    constructor(gridService, elementRef, renderer, ngZone) {\r\n        this.gridService = gridService;\r\n        this.elementRef = elementRef;\r\n        this.renderer = renderer;\r\n        this.ngZone = ngZone;\r\n        /** Emits when layout change */\r\n        this.layoutUpdated = new EventEmitter();\r\n        /** Emits when drag starts */\r\n        this.dragStarted = new EventEmitter();\r\n        /** Emits when resize starts */\r\n        this.resizeStarted = new EventEmitter();\r\n        /** Emits when drag ends */\r\n        this.dragEnded = new EventEmitter();\r\n        /** Emits when resize ends */\r\n        this.resizeEnded = new EventEmitter();\r\n        /**\r\n         * Parent element that contains the scroll. If an string is provided it would search that element by id on the dom.\r\n         * If no data provided or null autoscroll is not performed.\r\n         */\r\n        this.scrollableParent = null;\r\n        this._compactOnPropsChange = true;\r\n        this._preventCollision = false;\r\n        this._scrollSpeed = 2;\r\n        this._compactType = 'vertical';\r\n        this._rowHeight = 100;\r\n        this._cols = 6;\r\n    }\r\n    /** Whether or not to update the internal layout when some dependent property change. */\r\n    get compactOnPropsChange() { return this._compactOnPropsChange; }\r\n    set compactOnPropsChange(value) {\r\n        this._compactOnPropsChange = coerceBooleanProperty(value);\r\n    }\r\n    /** If true, grid items won't change position when being dragged over. Handy when using no compaction */\r\n    get preventCollision() { return this._preventCollision; }\r\n    set preventCollision(value) {\r\n        this._preventCollision = coerceBooleanProperty(value);\r\n    }\r\n    /** Number of CSS pixels that would be scrolled on each 'tick' when auto scroll is performed. */\r\n    get scrollSpeed() { return this._scrollSpeed; }\r\n    set scrollSpeed(value) {\r\n        this._scrollSpeed = coerceNumberProperty(value, 2);\r\n    }\r\n    /** Type of compaction that will be applied to the layout (vertical, horizontal or free). Defaults to 'vertical' */\r\n    get compactType() {\r\n        return this._compactType;\r\n    }\r\n    set compactType(val) {\r\n        this._compactType = val;\r\n    }\r\n    /** Row height in css pixels */\r\n    get rowHeight() { return this._rowHeight; }\r\n    set rowHeight(val) {\r\n        this._rowHeight = Math.max(1, Math.round(coerceNumberProperty(val)));\r\n    }\r\n    /** Number of columns  */\r\n    get cols() { return this._cols; }\r\n    set cols(val) {\r\n        this._cols = Math.max(1, Math.round(coerceNumberProperty(val)));\r\n    }\r\n    /** Layout of the grid. Array of all the grid items with its 'id' and position on the grid. */\r\n    get layout() { return this._layout; }\r\n    set layout(layout) {\r\n        /**\r\n         * Enhancement:\r\n         * Only set layout if it's reference has changed and use a boolean to track whenever recalculate the layout on ngOnChanges.\r\n         *\r\n         * Why:\r\n         * The normal use of this lib is having the variable layout in the outer component or in a store, assigning it whenever it changes and\r\n         * binded in the component with it's input [layout]. In this scenario, we would always calculate one unnecessary change on the layout when\r\n         * it is re-binded on the input.\r\n         */\r\n        this._layout = layout;\r\n    }\r\n    get config() {\r\n        return {\r\n            cols: this.cols,\r\n            rowHeight: this.rowHeight,\r\n            layout: this.layout,\r\n            preventCollision: this.preventCollision,\r\n        };\r\n    }\r\n    ngOnChanges(changes) {\r\n        let needsCompactLayout = false;\r\n        let needsRecalculateRenderData = false;\r\n        // TODO: Does fist change need to be compacted by default?\r\n        // Compact layout whenever some dependent prop changes.\r\n        if (changes.compactType || changes.cols || changes.layout) {\r\n            needsCompactLayout = true;\r\n        }\r\n        // Check if wee need to recalculate rendering data.\r\n        if (needsCompactLayout || changes.rowHeight) {\r\n            needsRecalculateRenderData = true;\r\n        }\r\n        // Only compact layout if lib user has provided it. Lib users that want to save/store always the same layout  as it is represented (compacted)\r\n        // can use KtdCompactGrid utility and pre-compact the layout. This is the recommended behaviour for always having a the same layout on this component\r\n        // and the ones that uses it.\r\n        if (needsCompactLayout && this.compactOnPropsChange) {\r\n            this.compactLayout();\r\n        }\r\n        if (needsRecalculateRenderData) {\r\n            this.calculateRenderData();\r\n        }\r\n    }\r\n    ngAfterContentInit() {\r\n        this.initSubscriptions();\r\n    }\r\n    ngAfterContentChecked() {\r\n        this.render();\r\n    }\r\n    resize() {\r\n        this.calculateRenderData();\r\n        this.render();\r\n    }\r\n    ngOnDestroy() {\r\n        this.subscriptions.forEach(sub => sub.unsubscribe());\r\n    }\r\n    compactLayout() {\r\n        this.layout = compact(this.layout, this.compactType, this.cols);\r\n    }\r\n    getItemsRenderData() {\r\n        return Object.assign({}, this._gridItemsRenderData);\r\n    }\r\n    getItemRenderData(itemId) {\r\n        return this._gridItemsRenderData[itemId];\r\n    }\r\n    calculateRenderData() {\r\n        const clientRect = this.elementRef.nativeElement.getBoundingClientRect();\r\n        this._gridItemsRenderData = layoutToRenderItems(this.config, clientRect.width, clientRect.height);\r\n        this._height = getGridHeight(this.layout, this.rowHeight);\r\n    }\r\n    render() {\r\n        this.renderer.setStyle(this.elementRef.nativeElement, 'height', `${this._height}px`);\r\n        this.updateGridItemsStyles();\r\n    }\r\n    updateGridItemsStyles() {\r\n        this._gridItems.forEach(item => {\r\n            const gridItemRenderData = this._gridItemsRenderData[item.id];\r\n            if (gridItemRenderData == null) {\r\n                console.error(`Couldn\\'t find the specified grid item for the id: ${item.id}`);\r\n            }\r\n            else {\r\n                item.setStyles(parseRenderItemToPixels(gridItemRenderData));\r\n            }\r\n        });\r\n    }\r\n    initSubscriptions() {\r\n        this.subscriptions = [\r\n            this._gridItems.changes.pipe(startWith(this._gridItems), switchMap((gridItems) => {\r\n                return merge(...gridItems.map((gridItem) => gridItem.dragStart$.pipe(map((event) => ({ event, gridItem, type: 'drag' })))), ...gridItems.map((gridItem) => gridItem.resizeStart$.pipe(map((event) => ({ event, gridItem, type: 'resize' }))))).pipe(exhaustMap(({ event, gridItem, type }) => {\r\n                    // Emit drag or resize start events. Ensure that is start event is inside the zone.\r\n                    this.ngZone.run(() => (type === 'drag' ? this.dragStarted : this.resizeStarted).emit(getDragResizeEventData(gridItem, this.layout)));\r\n                    // Get the correct newStateFunc depending on if we are dragging or resizing\r\n                    const calcNewStateFunc = type === 'drag' ? ktdGridItemDragging : ktdGridItemResizing;\r\n                    // Perform drag sequence\r\n                    return this.performDragSequence$(gridItem, event, (gridItemId, config, compactionType, draggingData) => calcNewStateFunc(gridItem, config, compactionType, draggingData)).pipe(map((layout) => ({ layout, gridItem, type })));\r\n                }));\r\n            })).subscribe(({ layout, gridItem, type }) => {\r\n                this.layout = layout;\r\n                // Calculate new rendering data given the new layout.\r\n                this.calculateRenderData();\r\n                // Emit drag or resize end events.\r\n                (type === 'drag' ? this.dragEnded : this.resizeEnded).emit(getDragResizeEventData(gridItem, layout));\r\n                // Notify that the layout has been updated.\r\n                this.layoutUpdated.emit(layout);\r\n            })\r\n        ];\r\n    }\r\n    /**\r\n     * Perform a general grid drag action, from start to end. A general grid drag action basically includes creating the placeholder element and adding\r\n     * some class animations. calcNewStateFunc needs to be provided in order to calculate the new state of the layout.\r\n     * @param gridItem that is been dragged\r\n     * @param pointerDownEvent event (mousedown or touchdown) where the user initiated the drag\r\n     * @param calcNewStateFunc function that return the new layout state and the drag element position\r\n     */\r\n    performDragSequence$(gridItem, pointerDownEvent, calcNewStateFunc) {\r\n        return new Observable((observer) => {\r\n            // Retrieve grid (parent) and gridItem (draggedElem) client rects.\r\n            const gridElemClientRect = getMutableClientRect(this.elementRef.nativeElement);\r\n            const dragElemClientRect = getMutableClientRect(gridItem.elementRef.nativeElement);\r\n            const scrollableParent = typeof this.scrollableParent === 'string' ? document.getElementById(this.scrollableParent) : this.scrollableParent;\r\n            this.renderer.addClass(gridItem.elementRef.nativeElement, 'no-transitions');\r\n            this.renderer.addClass(gridItem.elementRef.nativeElement, 'ktd-grid-item-dragging');\r\n            // Create placeholder element. This element would represent the position where the dragged/resized element would be if the action ends\r\n            const placeholderElement = this.renderer.createElement('div');\r\n            placeholderElement.style.width = `${dragElemClientRect.width}px`;\r\n            placeholderElement.style.height = `${dragElemClientRect.height}px`;\r\n            placeholderElement.style.transform = `translateX(${dragElemClientRect.left - gridElemClientRect.left}px) translateY(${dragElemClientRect.top - gridElemClientRect.top}px)`;\r\n            this.renderer.addClass(placeholderElement, 'ktd-grid-item-placeholder');\r\n            this.renderer.appendChild(this.elementRef.nativeElement, placeholderElement);\r\n            let newLayout;\r\n            // TODO (enhancement): consider move this 'side effect' observable inside the main drag loop.\r\n            //  - Pros are that we would not repeat subscriptions and takeUntil would shut down observables at the same time.\r\n            //  - Cons are that moving this functionality as a side effect inside the main drag loop would be confusing.\r\n            const scrollSubscription = this.ngZone.runOutsideAngular(() => (!scrollableParent ? NEVER : this.gridService.mouseOrTouchMove$(document).pipe(map((event) => ({\r\n                pointerX: ktdPointerClientX(event),\r\n                pointerY: ktdPointerClientY(event)\r\n            })), ktdScrollIfNearElementClientRect$(scrollableParent, { scrollStep: this.scrollSpeed }))).pipe(takeUntil(ktdMouseOrTouchEnd(document))).subscribe());\r\n            /**\r\n             * Main subscription, it listens for 'pointer move' and 'scroll' events and recalculates the layout on each emission\r\n             */\r\n            const subscription = this.ngZone.runOutsideAngular(() => merge(combineLatest([\r\n                this.gridService.mouseOrTouchMove$(document),\r\n                ...(!scrollableParent ? [of({ top: 0, left: 0 })] : [\r\n                    ktdGetScrollTotalRelativeDifference$(scrollableParent).pipe(startWith({ top: 0, left: 0 }) // Force first emission to allow CombineLatest to emit even no scroll event has occurred\r\n                    )\r\n                ])\r\n            ])).pipe(takeUntil(ktdMouseOrTouchEnd(document))).subscribe(([pointerDragEvent, scrollDifference]) => {\r\n                pointerDragEvent.preventDefault();\r\n                /**\r\n                 * Set the new layout to be the layout in which the calcNewStateFunc would be executed.\r\n                 * NOTE: using the mutated layout is the way to go by 'react-grid-layout' utils. If we don't use the previous layout,\r\n                 * some utilities from 'react-grid-layout' would not work as expected.\r\n                 */\r\n                const currentLayout = newLayout || this.layout;\r\n                const { layout, draggedItemPos } = calcNewStateFunc(gridItem, {\r\n                    layout: currentLayout,\r\n                    rowHeight: this.rowHeight,\r\n                    cols: this.cols,\r\n                    preventCollision: this.preventCollision\r\n                }, this.compactType, {\r\n                    pointerDownEvent,\r\n                    pointerDragEvent,\r\n                    gridElemClientRect,\r\n                    dragElemClientRect,\r\n                    scrollDifference\r\n                });\r\n                newLayout = layout;\r\n                this._height = getGridHeight(newLayout, this.rowHeight);\r\n                this._gridItemsRenderData = layoutToRenderItems({\r\n                    cols: this.cols,\r\n                    rowHeight: this.rowHeight,\r\n                    layout: newLayout,\r\n                    preventCollision: this.preventCollision,\r\n                }, gridElemClientRect.width, gridElemClientRect.height);\r\n                const placeholderStyles = parseRenderItemToPixels(this._gridItemsRenderData[gridItem.id]);\r\n                // Put the real final position to the placeholder element\r\n                placeholderElement.style.width = placeholderStyles.width;\r\n                placeholderElement.style.height = placeholderStyles.height;\r\n                placeholderElement.style.transform = `translateX(${placeholderStyles.left}) translateY(${placeholderStyles.top})`;\r\n                // modify the position of the dragged item to be the once we want (for example the mouse position or whatever)\r\n                this._gridItemsRenderData[gridItem.id] = Object.assign(Object.assign({}, draggedItemPos), { id: this._gridItemsRenderData[gridItem.id].id });\r\n                this.render();\r\n            }, (error) => observer.error(error), () => {\r\n                this.ngZone.run(() => {\r\n                    // Remove drag classes\r\n                    this.renderer.removeClass(gridItem.elementRef.nativeElement, 'no-transitions');\r\n                    this.renderer.removeClass(gridItem.elementRef.nativeElement, 'ktd-grid-item-dragging');\r\n                    // Remove placeholder element from the dom\r\n                    // NOTE: If we don't put the removeChild inside the zone it would not work... This may be a bug from angular or maybe is the intended behaviour, although strange.\r\n                    // It should work since AFAIK this action should not be done in a CD cycle.\r\n                    this.renderer.removeChild(this.elementRef.nativeElement, placeholderElement);\r\n                    if (newLayout) {\r\n                        // TODO: newLayout should already be pruned. If not, it should have type Layout, not KtdGridLayout as it is now.\r\n                        // Prune react-grid-layout compact extra properties.\r\n                        observer.next(newLayout.map(item => ({\r\n                            id: item.id,\r\n                            x: item.x,\r\n                            y: item.y,\r\n                            w: item.w,\r\n                            h: item.h,\r\n                            minW: item.minW,\r\n                            minH: item.minH,\r\n                            maxW: item.maxW,\r\n                            maxH: item.maxH,\r\n                        })));\r\n                    }\r\n                    else {\r\n                        // TODO: Need we really to emit if there is no layout change but drag started and ended?\r\n                        observer.next(this.layout);\r\n                    }\r\n                    observer.complete();\r\n                });\r\n            }));\r\n            return () => {\r\n                scrollSubscription.unsubscribe();\r\n                subscription.unsubscribe();\r\n            };\r\n        });\r\n    }\r\n}\r\nKtdGridComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.14\", ngImport: i0, type: KtdGridComponent, deps: [{ token: KtdGridService }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });\r\nKtdGridComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"12.2.14\", type: KtdGridComponent, selector: \"ktd-grid\", inputs: { scrollableParent: \"scrollableParent\", compactOnPropsChange: \"compactOnPropsChange\", preventCollision: \"preventCollision\", scrollSpeed: \"scrollSpeed\", compactType: \"compactType\", rowHeight: \"rowHeight\", cols: \"cols\", layout: \"layout\" }, outputs: { layoutUpdated: \"layoutUpdated\", dragStarted: \"dragStarted\", resizeStarted: \"resizeStarted\", dragEnded: \"dragEnded\", resizeEnded: \"resizeEnded\" }, providers: [\r\n        {\r\n            provide: GRID_ITEM_GET_RENDER_DATA_TOKEN,\r\n            useFactory: ktdGridItemGetRenderDataFactoryFunc,\r\n            deps: [KtdGridComponent]\r\n        }\r\n    ], queries: [{ propertyName: \"_gridItems\", predicate: KtdGridItemComponent, descendants: true }], usesOnChanges: true, ngImport: i0, template: \"<ng-content></ng-content>\\r\\n\", styles: [\"ktd-grid{display:block;position:relative;width:100%}ktd-grid ktd-grid-item.ktd-grid-item-dragging{z-index:1000}ktd-grid ktd-grid-item.no-transitions{transition:none!important}ktd-grid .ktd-grid-item-placeholder{position:absolute;background-color:#8b0000;opacity:.6;z-index:0;transition-property:transform;transition:all .15s ease}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.14\", ngImport: i0, type: KtdGridComponent, decorators: [{\r\n            type: Component,\r\n            args: [{\r\n                    selector: 'ktd-grid',\r\n                    templateUrl: './grid.component.html',\r\n                    styleUrls: ['./grid.component.scss'],\r\n                    encapsulation: ViewEncapsulation.None,\r\n                    changeDetection: ChangeDetectionStrategy.OnPush,\r\n                    providers: [\r\n                        {\r\n                            provide: GRID_ITEM_GET_RENDER_DATA_TOKEN,\r\n                            useFactory: ktdGridItemGetRenderDataFactoryFunc,\r\n                            deps: [KtdGridComponent]\r\n                        }\r\n                    ]\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: KtdGridService }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.NgZone }]; }, propDecorators: { _gridItems: [{\r\n                type: ContentChildren,\r\n                args: [KtdGridItemComponent, { descendants: true }]\r\n            }], layoutUpdated: [{\r\n                type: Output\r\n            }], dragStarted: [{\r\n                type: Output\r\n            }], resizeStarted: [{\r\n                type: Output\r\n            }], dragEnded: [{\r\n                type: Output\r\n            }], resizeEnded: [{\r\n                type: Output\r\n            }], scrollableParent: [{\r\n                type: Input\r\n            }], compactOnPropsChange: [{\r\n                type: Input\r\n            }], preventCollision: [{\r\n                type: Input\r\n            }], scrollSpeed: [{\r\n                type: Input\r\n            }], compactType: [{\r\n                type: Input\r\n            }], rowHeight: [{\r\n                type: Input\r\n            }], cols: [{\r\n                type: Input\r\n            }], layout: [{\r\n                type: Input\r\n            }] } });\n\nclass KtdGridModule {\r\n}\r\nKtdGridModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.14\", ngImport: i0, type: KtdGridModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\nKtdGridModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.14\", ngImport: i0, type: KtdGridModule, declarations: [KtdGridComponent,\r\n        KtdGridItemComponent,\r\n        KtdGridDragHandle,\r\n        KtdGridResizeHandle], imports: [CommonModule], exports: [KtdGridComponent,\r\n        KtdGridItemComponent,\r\n        KtdGridDragHandle,\r\n        KtdGridResizeHandle] });\r\nKtdGridModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.14\", ngImport: i0, type: KtdGridModule, providers: [\r\n        KtdGridService\r\n    ], imports: [[\r\n            CommonModule\r\n        ]] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.14\", ngImport: i0, type: KtdGridModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    declarations: [\r\n                        KtdGridComponent,\r\n                        KtdGridItemComponent,\r\n                        KtdGridDragHandle,\r\n                        KtdGridResizeHandle\r\n                    ],\r\n                    exports: [\r\n                        KtdGridComponent,\r\n                        KtdGridItemComponent,\r\n                        KtdGridDragHandle,\r\n                        KtdGridResizeHandle\r\n                    ],\r\n                    providers: [\r\n                        KtdGridService\r\n                    ],\r\n                    imports: [\r\n                        CommonModule\r\n                    ]\r\n                }]\r\n        }] });\n\n/*\r\n * Public API Surface of grid\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { GRID_ITEM_GET_RENDER_DATA_TOKEN, KTD_GRID_DRAG_HANDLE, KTD_GRID_RESIZE_HANDLE, KtdGridComponent, KtdGridDragHandle, KtdGridItemComponent, KtdGridModule, KtdGridResizeHandle, __gridItemGetRenderDataFactoryFunc, ktdGridCompact, ktdGridItemGetRenderDataFactoryFunc, ktdTrackById, parseRenderItemToPixels };\n"]},"metadata":{},"sourceType":"module"}